package com.thinkwithu.www.kotlindemo

import androidx.test.InstrumentationRegistry
import androidx.test.runner.AndroidJUnit4

import org.junit.Test
import org.junit.runner.RunWith

import org.junit.Assert.*

/**
 * Instrumented test, which will execute on an Android device.
 *
 * See [testing documentation](http://d.android.com/tools/testing).
 */
@RunWith(AndroidJUnit4::class)
class ExampleInstrumentedTest {
    @Test
    fun useAppContext() {
        // Context of the app under test.
        val appContext = InstrumentationRegistry.getTargetContext()
        assertEquals("com.thinkwithu.www.kotlindemo", appContext.packageName)
    }
}
package com.thinkwithu.www.kotlindemo

import java.lang.Exception
import java.lang.IndexOutOfBoundsException
import java.lang.NumberFormatException

/**
 * Copyright (C), 2015-2019, 北京九州申友教育咨询有限公司
 * Author: sean
 * Date: 2019/4/18 16:14
 * Description: ${DESCRIPTION}
 */
fun main() {
//    basictype()
    var argus = arrayOf(5, 10)
//    bianli(argus)
//    abnormal(argus);
//    expression(argus)
//    parameter(4, 4, a = "1")
//    change("a", "b", "v")
//    string()
//    nullText()
//    range()
//    compare()
//    char('5')
//    array(intArrayOf(5, 8))
    string("hello")
}


/**
 * 基本数据类型
 */
fun basictype() {
    //数字：Double,Float,Long,Int,Short,Byte
    var INta = 1 //可以不用指定类型，使用时会自动判断类型
    var LongA = 5L//长整型，用L标记
    var OXA = 0Xff//十六进制，以0x开头标记
    var ObA = 0b1011//二进制，以0b开头
    //不支持8进制
    var DoubleA = 6.55//默认是double类型
    var FloatA = 6.5f//单精度以f结尾
    var oneMillion = 1_000_000//以下划线分割，易读
}

/**
 *  for 循环
 */
fun bianli(argus: ArrayList<String>) {
    for (value in argus) {
        println(value)
    }
    for ((index, value) in argus.withIndex()) {
        println("$index->$value")
    }
    for (indexvalue in argus.withIndex()) {
        println(indexvalue)
    }

}

/**
 * 异常处理
 */

fun abnormal(argus: Array<String>) {
    try {
        var a = argus[0]
        var b = argus[1]
        var c = a.toInt() + b.toInt()
        print(c)
    } catch (e: NumberFormatException) {
        println("您给的是整数吗")
    } catch (e: IndexOutOfBoundsException) {
        println("您给的是两个整数吗")
    } finally {
        println("谢谢使用")
    }

}

/**
 * 表达式
 */
fun expression(argus: Array<Int>) {
    var a = try {
        argus[0].toInt() / argus[1].toInt()
    } catch (e: Exception) {
        e.printStackTrace()
    } finally {
        println("我是表达式")
    }
    println(a)
}

/**
 *vararg修饰变长参数
 * 具名参数
 * 默认参数
 */
fun parameter(vararg ints: Int, a: String, c: Double = 5.2) {
    for (b in ints) println(b)
    println(a)
    println(c)
}

//函数以fun关键字修饰，参数是以变量：类型形式，返回值是以;类型写在最后 ，；可以省略
fun func(a: Int, b: String): Int {
    return 1
}

//表达式作为函数体，返回类型自动判断
fun sun(a: Int, b: Int) = a + b

public fun sum(a: Int, b: Int) = a + b

//无返回值，unit可以省略
fun printsum(a: Int, b: Int): Unit {
    println(a + b)
}

fun printsum1(a: Int, b: Int) {
    println(a + b)
}

//可变长参数用vararg显示
fun change(vararg v: String) {
    for (i in v)
        println(v)
    println("b")
    println("vvv")
}

//var 修饰可变变量，
var cc: String = "7"

fun text() {
//编译器自动识别类型
    var aa = 4
    aa += 1
}

//字符串模板 以$符号
fun string() {
    var a = "a"
    var b = "this is $a"
    var c = "this is ${text()}"
    println(b)
    println(c)
}


//null 安全机制
fun nullText() {
    var a: String? = null// ?表示可为空
//    var b = a!!.toInt()//！！表示如果为null则抛出异常
    var c = a?.toInt()//?表示如果为null则返回null
    var d = a?.toInt() ?: -1//?:表示 如果为null则返回-1
    println(a)
//    println(b)
    println(c)
    println(d)
}


fun typeText(obj: Any): Int? {
    if (obj is String) {
        return obj.length  //obj自动转换成String
    }
    return null
}


fun typeText1(obj: Any): Int? {
    if (obj !is String) {
        return null
    }
    return obj.length //obj自动转换String
}

fun typeText2(obj: Any): Int? {
    if (obj is String && obj.length > 0) {//obj自动转换String
        return obj.length
    }
    return null
}

//区间
fun range() {
    for (i in 1..5) println(i)
    for (i in 1..10 step 2) println(i)
    for (i in 4 downTo 1 step 1) println(i)
    for (i in 2 until 7) println(i)
}


//kt没有基础数据类型，只有封装的数字类型
//两个=表示，比较值的大小，三个=表示比较地址
fun compare() {
    val a = 100
    val b: Int? = a
    val c: Int? = a
    println(c == b)
    println(c === b)
}

fun type() {
    var a: Int = 5
    var b: Long = a.toLong()
    var c: String = a.toString()
}

//字符：不能和数字类型直接操作,可以显示转换成数字类型
fun char(c: Char): Int? {
    if (c in '0'..'9') {
        return c.toInt()
    }
    return null
}

//数组，用Array实现，此外还有IntArray,DoubleArray,等等
fun array(ary: IntArray) {
    println(ary.size)
    println(ary[0])
    ary[0] = 100
    println(ary[0])
}

//字符串可以被遍历，用三个"""可以支持换行操作，用trimmargin去掉字符串前面多余的空格，默认是以竖线分割
fun string(a: String) {
    for (s in a) {
        println(s)
    }
    var s1 = """
多行字符串
        支持
多行字符串用三个双引号
    """
    var s2 = """
        5多行字符串
        5支持
        5多行字符串用三个双引号
    """.trimMargin("5")
    println(s1)
    println(s2)
}















































































package com.thinkwithu.www.kotlindemo

/**
 * Copyright (C), 2015-2019, 北京九州申友教育咨询有限公司
 * Author: sean
 * Date: 2019/4/23 17:13
 * Description: ${DESCRIPTION}
 */
fun main() {

    /* var f = FourClass(88)
     f.cc()
     var fi = Five("", 1, "")*/
    /* var a = eight.nine(10).foo()
     println(a)*/
//    var c = C()
//    c.foo()

//    val user = User();
//    user.extension()

    /* val intarray = intArrayOf(4, 9, 6)
     intarray.extecsion()
     for (i in intarray) {
         println(i)
     }*/
//    entity(v())
//    val yn = yun();
//    yn.foo()

//    var a: String? = null
//    println(a.toString())

//    myclass.foo()
//    moon().sunDo(sun(
//    bb().bbDo(aa())
//    pp().dp(tt1())
//    pp1().dp(tt())
    val jack = mydata("jack", 18)
    val oldjack = jack.copy(age = 45)//copy方法对
    println(jack)
    println(oldjack)

}

//类用class修饰，
class FirstClass {
    public var change: Int = 5 //var申明可变变量
    val a: String = "4" //val申明常量，相当于final


    //成员函数
    fun foo() {
        println("foo")
    }


}

class SecondClass constructor(a: String) {
    //类的主构造器，用constructor修饰，如果没有用可见修饰符修饰，那么constructor可以省略
    var firstClass = FirstClass()//我们可以像使用普通方法那样对类进行实例化，kt中没有new关键字
    var b: Int = 4

    //写了主构造器，能写其他构造器就用this代理主构造器
    /*  constructor(username: String, age: Int){
      }
      constructor(b: Int) {
          this.b = b
      }*/


    fun foo() {
        firstClass.change//通过类名.来获取属性及方法
        firstClass.foo()
    }
}

class ThreeClass() {
    var a = 5
        get() {
            return field + 2008//field只能在get和set方法中使用，用来代替变量的value
        }
        set(value) {
            field = value
        }
    var b = 9
        get
        set

    lateinit var c: String//lateinit用来延迟初始化， 不然在声明变量的时候都必须初始化,只能用于变量var
}

class FourClass(var a: Int) { //主构造器里面申明的变量可以在类范围使用

    init { //类的初始化方法，值的初始化放在init方法里面
        println("init  a  的值是$a")
    }

    fun cc() {
        a = 9
        println("cc  a  的值 是$a")
    }
}


class Five(a: Int, c: String) { //主构造函数如果有参数，那么次构造函数也必需接收这些参数，并为主构造函数代理，使用this关键字
    constructor(b: String, a: Int, c: String) : this(a, c) {

    }
}

open class animal(a: Int) { //open修饰的类才能被继承，默认是被final修饰
    open fun foo() { //open修饰的方法才能被重写，默认是final修饰

    }
}

class person : animal(5) {
    //继承用:格式,如果父类有传参构造方法，那么子类必须实现它
    override fun foo() {

    }
}


abstract class six(a: Int) { //abstract修饰抽象类 抽象类不需要用open修饰，也可以被继承
    abstract fun foo() //abstract修饰抽象方法，也可以不用open修饰
}

class seven : six(8) {
    override fun foo() {
        TODO("not implemented") //To change body of created functions use File | Settings | File Templates.
    }
}

class eight() {
    class nine(a: Int) { //调用嵌套类使用：外部类.嵌套类.属性（方法）
        fun foo() = 8
    }
}


class head {
    var a = 100
    fun b() = 99
    inner class foot() { //内部类用inner 修饰，内部类持有外部类的引用，所以能直接访问外部类的属性和方法
        var c = a
        fun d() {
            var e = b()
        }
    }
}

class book : Any() //所有的类都默认继承自any类。


open class Person(name: String)

class student(name: String, height: Int) : Person(name) //子类有主构造函数，则基类必须在主构造函数中立即初始化

class teacher : Person {  //子类没有主构造函数，则必须在每一个次构造函数中,用super关键字实例化父类
    constructor(name: String) : super(name) {

    }

    constructor(height: Int, name: String) : super(name) {

    }

}


open class A {
    open val a = 99 //属性被open修饰，可以被重写
    open fun foo() {
        println("A")
    }
}

interface B {
    fun foo() { //接口的方法默认是open
        println("B")
    }
}

class C : A(), B { //子类c继承A和实现B,如果A和B有相同的方法，则子类C必须重写这个方法，我们可以用super<>关键字调用哪个父类的方法
    override fun foo() {  //kotlin和java一样，也不能多继承
        super<A>.foo()
        super<B>.foo()
    }

    override var a = 100  //val修饰的常量可以被重写成var变量，反之则不行
    fun d() {
        a = 999
    }

}

interface t {
    var a: Int //变量不允许被初始化，只能是抽象的
    fun b()
    fun c() { //方法可以有默认实现
        println("c")
    }

}

interface tf {
    fun b() {
        println("tf b")
    }

    fun c() {
        println("tf  c")
    }

}


class imp : t {  //实现接口，用: ，
    override var a: Int = 5//子类必须重写接口的属性值

    override fun b() { //没有默认实现的方法，必须重写
        TODO("not implemented") //To change body of created functions use File | Settings | File Templates.
    }
}

class imp1 : t, tf {
    override var a: Int = 88

    override fun b() {//重写接口没被实现的方法，必须重写
        super<tf>.b()
    }

    override fun c() {//重写 两个接口都有的方法 必须重写
        super<t>.c()
        super<tf>.c()
    }

}


class User//空类

//作用域在顶级包下
fun User.extension() {//扩展函数  以fun修饰，以类名.方法名进行扩展，对原类不产生任何影响
    println("我是扩展函数")
}

fun IntArray.extecsion() { //有了扩展函数之后 就可以很方便的对系统函数进行扩展了
    var a = this[0]
    this[0] = this[2]
    this[2] = a
}

//扩展函数是静态解析的，并不是接收者类型的虚拟成员,到底执行哪个扩展函数，是由调用者直接决定的，而不是由动态调用者决定，
//换句话说如果是父类调用扩展函数，而子类也有该扩展函数，当传入的对象是子类时，也是有父类执行扩展函数
open class w

class v : w()

fun w.foo() {
    println("我是w的扩展函数")
}

fun v.foo() {
    println("我是v的扩展函数")
}

fun entity(w1: w) {
    w1.foo()
}


//当扩展函数和成员函数相同时，会优先调用成员函数
class yun {
    fun foo() {
        println("成员")
    }
}

fun yun.foo() {
    println("扩展")
}

//null也可以有扩展函数
fun Any?.haha() {

}

//扩展属性 ,只能支持val，由于没有filed，所以不能被初始化，只能显示初始化
//只能定义在类和kt文件中，不允许定义在方法中
val User.to: Int
    get() {
        return 4
    }

fun User.text() {
    val a = 8
    println(this.to)
}


//伴生对象
class myclass {
    companion object {

    }
}

fun myclass.Companion.foo() {
    println("我是伴生对象的扩展方法啊")
}


class sun {
    fun speak() {
        println("我是太阳，在说话")
    }
}


class moon {

    fun hahaa() {
        println("我是月亮的哈哈")
    }

    //当一个类的扩展函数是另一个类的成员函数时，这个函数内既可以调用扩展接受者的成员函数，也可以调用分发接收者的成员函数
    //这个方法的作用域只能在该类中
    fun sun.sing() {
        speak()
        hahaa()
        println("我是太阳，在唱歌")
    }

    fun sunDo(s: sun) {
        s.sing()
    }


}


class aa {
    fun foo() {
        println("aa foo")
    }
}

class bb {
    fun foo() {
        println("bb foo")
    }

    fun aa.other() {
        foo() //当扩展接受者和分发接收者都有同样的方法时，会优先调用扩展接收者
        this@bb.foo()//可以使用this关键字@类名调用分发接收者的方法
        println("other")
    }

    fun bbDo(a: aa) {
        a.other()
    }

}


open class tt

class tt1 : tt()


open class pp {

    open fun tt.dt() {
        println("pp里面的tt")
    }

    open fun tt1.dt() {
        println("pp里面的tt1")
    }

    fun dp(t: tt) { //针对扩展接收者，仍然是静态的，不会因为动态类型而改变
        t.dt()
    }
}


//针对扩展接收者和分发接收者而言，扩展接收者重写之后也是属于静态解析，而分发接收者 则不同
class pp1 : pp() {
    override fun tt.dt() {  //方法被重写了，用pp1去调用也会生效，
        println("pp1 里面的tt")
    }

    override fun tt1.dt() {
        println("pp1 里面的tt1")
    }

}

//数据类 用data 关键字修饰，主构造方法必须有参数，可以用copy方法复制数据对象的数据
data class mydata(val name: String, val age: Int)

























































































package com.thinkwithu.www.kotlindemo

/**
 * Copyright (C), 2015-2019, 北京九州申友教育咨询有限公司
 * Author: sean
 * Date: 2019/4/23 12:02
 * Description: ${DESCRIPTION}
 */

// main方法是kt的进入方法，好比java的main方法
fun main() {
//    conditionif(5, 9);
//    conditionwhen("李四", 5)
//    conditionfor()
    conditionwhile()
}

fun conditionif(a: Int, b: Int) {
    //传统用法
    var max: Int = b
    if (a > b) max = a
    //用if  else
    if (a > b) {
        max = a
    } else {
        max = b
    }
    //if作为表达式，可以进行赋值，取代java的三目运算符
    max = if (a > b) {
        a
    } else {
        b
    }
    max = if (a > b) a else b
    println("max的值是$max")

    if (a in 5..9) {
        println("$a 在区间")
    }
}

//when 相当于增强版的java switch case语句 支持任意类型，不用写break
fun conditionwhen(a: String, b: Int) {
    when (a) {
        "张三" -> println("我是张三")
        "李四" -> println("我是李四")
        else -> println("我是王五")
    }

    when (b) {
        4, 5 -> println("b的值是4或者5")//条件可以写在一起，
        in 1..10 -> println("在区间1到10之间")//支持in  ,!in写法
        !in 50..100 -> println("不在50到100之间")
        is Int -> println("是整型")//支持is  !is写法
    }

    when {
        b == 1 -> println("b的值是1") //不传参，取代if  else 的写法，不传参数
        b == 2 -> println("b的值是2")
        else -> println("b的值不知道是多少")
    }

    var d = when (b) { //when语句作为表达式，可以进行赋值
        1 -> 11
        2 -> 22
        else -> 8
    }
    println(d)
}

fun conditionfor() {
    var a = arrayOf(4, 5, 6)
    for (b in a) {
        println(b)
    }
    for (c in a.withIndex()) {
        println(c)
    }
    for (d in a) {
        if (d == 4) continue //结束本次循环，继续下一次
        if (d == 5) break //跳出循环
    }

    oop@ for (e in a) {  //以名字加上@符号 给表达式取名
        for (j in a) {
            break@oop //跳出最外层循环
        }
    }


}

fun conditionwhile() {
    var a = 0
    while (a > 0) { //满足条件 就会继续执行
        println(--a)
    }
    println("--------------")
    do {
        println(--a)  //先执行一次，在进去while判断
    } while (a > 0)


}









package com.thinkwithu.www.kotlindemo.dsl

/**
 * Author: sean
 * Date: 2019/5/14 11:15
 */

/**
 * <html>
 *     <body>
 *    </body>
</html>
 */

fun main() {
    //高阶函数
    val html = html {
        head {

        }
        body {
            div {

            }
        }

    }
    println(html)
}

fun Body.div(block: () -> Unit) {
    val d=Div()
    setTag(d)
}


fun html(block: Html.() -> Unit): Html {
    val h = Html()
    block(h)
    return h
}

fun Html.body(block:Body.() -> Unit) {
    val b = Body()
    block(b)
    setTag(b)
}

fun Html.head(block: () -> Unit) {
    val h = Head()
    setTag(h)
}


open class Tag(val name: String) {
    val list = ArrayList<Tag>()

    fun setTag(tag: Tag) {
        list.add(tag)
    }

    override fun toString(): String {
        val stringBuilder = StringBuilder()
        stringBuilder.append("<$name>")
        list.forEach { stringBuilder.append(it.toString()) }
        stringBuilder.append("</$name>")
        return stringBuilder.toString()
    }
}

class Html : Tag("html")
class Body : Tag("body")
class Head : Tag("head")
class Div : Tag("div")
package com.thinkwithu.www.kotlindemo.fanxing

/**
 * Author: sean
 * Date: 2019/5/8 10:17
 */

fun main(args: Array<String>) {
    aaa.cc()
}

abstract class annimal

class Dog : annimal()

class cat : annimal()

open class Box<T>(thing: T)

class AnnimalBox(annimal: annimal) : Box<annimal>(annimal)


class aaa() {
    companion object {
        var a = ""
        fun cc() {

        }
    }
}
package com.thinkwithu.www.kotlindemo.fanxing.函数回调

/**
 * Author: sean
 * Date: 2019/5/13 14:51
 */


fun main() {
    val us = usa()
    us.chinesehome({
        it.copy()
    })
}

data class xinpian(var name: String)

class aaa(aaa5: Int) {
}

class aaa1(var int5: Int) {
    fun cc(){
        int5=9
    }
}

class chinese() {
    val us = usa()

}

class usa() {
    fun chinesehome(f: (xinpian) -> Unit) {
        val xinpian = xinpian("小霸王")
        f.invoke(xinpian)
    }
}


package com.thinkwithu.www.kotlindemo.fanxing

/**
 * Author: sean
 * Date: 2019/5/8 16:25
 */


fun main() {
//    danli.instance.name
//    danli.instance.age
//    println(text(C()))
    //获取函数的引用，用::函数名可以获取函数的引用
    /*  println(jisuan(4, 7, ::add))
      //lambda 表达式
      println(jisuan(77, 99, { m, n ->
          println()
          m - n
      }))
      //lambda表达式  去括号  括号前移
      println(jisuan(4, 9) { m, n ->
          m + n
      })*/
  /*  lamba(4)
    //使用lambda的时候，如果参数只有一个，那么可以省略参数不写，默认参数就是it
    jisuan(4, {
        it + 10
    })*/
    var list= listOf<String>("a","b","c")
   /* list.filter {  }*/

}

class danli() {
    var name = "asd"
    val age by lazy {
        5
    }
    //lateinit  不能修饰基本类型
    lateinit var height: String

    companion object {
        val instance by lazy {
            danli()
        }
    }

}


open class A
class B : A()
class C : A()
class D : A()

fun text(a: A): Boolean {
    return when (a) {
        is B -> true
        is D -> true
        else -> false
    }
}


fun add(a: Int, b: Int) = a + b
fun jian(a: Int, b: Int) = a - b

//高阶函数
fun jisuan(a: Int, b: Int, block: (Int, Int) -> Int): Int {
    return block.invoke(a, b)
}

//高阶函数
fun jisuan(a: Int, block: (Int) -> Int): Int {
    return block.invoke(a)
}

val lamba = { a: Int ->
    a
}








package com.thinkwithu.www.kotlindemo.fanxing.四大函数


/**
 * Author: sean
 * Date: 2019/5/13 11:33
 */

fun main(args: Array<String>) {
    val list = arrayListOf<String>("aaa")
    /**
     * 1.任何类型的扩展方法
     * 2.参数是有接收者的函数
     * 返回值是自己
     */
    list.apply {
        add("222")
        add("222")
    }

    /**
     * 1.参数是有一个参数的函数，参数函数的返回值是泛型R
     * 函数的返回值是参数函数的返回值
     */
    list.let {
        it.add("44")
        "ssss"
    }.length

    /**
     * 相当于是apply和let方法的合成题
     * 有两个参数，第一个参数是任意类型，第二个参数是有接收类型的函数，
     * 函数的返回值是第二个函数参数的返回值
     */
    with(8, {
        toString()
        "aaa"
    }).length

    /*
    1.参数是有接收类型的函数，接收类型是调用类型
    函数的返回值是函数参数的返回值
     */
    list.run {
        add("aaa")
        "rrrr"
    }.toString()


}

package com.thinkwithu.www.kotlindemo.heima

import java.lang.Exception
import java.math.BigInteger

/**
 * Copyright (C), 2015-2019, 北京九州申友教育咨询有限公司
 * Author: sean
 * Date: 2019/5/5 10:54
 * Description: ${DESCRIPTION}
 */

//程序的主方法
fun main(argus: Array<String>) {
//    println(sayHello("xiaozhang"))
//    println(checkAge(19))
//    saveLog(1)
//    println(darary("滁洲岛"))
//    qujian()
//    add(3, 2)
//    hanshu()
//    zhouchang(a = 6.3f)
//    jiaohu()
    println(jiecheng(BigInteger("100000")))
}

fun basic1() {
    var a = 5  //智能推断类型  var  可变的数据
    var b: Byte = 9 //显示指定类型
    var c: Int //指定类型，可以被重新赋值
    c = 99
    val number = "No.123598" //val 是常量，不能被修改，只读数据，确定了就不能被修改
//    number = "sdfdf"

    var d: Boolean
    d = 5 > 4

}


fun sayHello(name: String): String {
    return name
}

fun checkAge(age: Int): Boolean {
    return age > 18
}

fun saveLog(logLeavel: Int) {
    println(logLeavel)
}


//字符串模板    用$符号
fun darary(place: String): String {
    var comtent = """
        今天我去了${place}这里游玩，真好玩
    """.trimIndent()
    return comtent
}


fun qujian() {
    var a = 1..100000
    var result: Int = 0
    for (c in a) {
        result = result + c
    }
    println(result)
}

fun add(a: Int, b: Int) = a + b

fun hanshu() {
    var a = { x: Int, y: Int -> x + y }
    var b: (Int, Int) -> Int = { x, y -> x + y }
    var resule = a(3, 6)
    println(resule)
}


fun zhouchang(pi: Float = 3.14f, a: Float): Float = a * pi


fun jiaohu() {
    while (true) {
        try {
            println("********************************")
            println("请输入第一个数字")
            var a = readLine()!!.toInt()
            println("请输入第二个数字")
            var b = readLine()!!.toInt()
            println("$a + $b =${a + b}")
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }
}



// tailrec  尾递归 优化   不管多少次都要执行
tailrec fun  jiecheng(a: BigInteger): BigInteger {
    println(100000 - a.toInt())
    if (a == BigInteger.ONE) {
        return BigInteger.ONE
    } else {
        return jiecheng(a - BigInteger.ONE)
    }
}





















package com.thinkwithu.www.kotlindemo.heima26

/**
 * Author: sean
 * Date: 2019/5/5 17:36
 */

fun main(args: Array<String>) {
//    han_shu_shi()
    //::函数名，用于声明函数对象
    var add = ::add
    //有两种方式，函数对象的调用，
    println(add(1, 2))
    //这种方式更加安全
    println(add?.invoke(1, 2))


}

fun han_shu_shi() {
    var stringlist = listOf<String>("a", "b", "c")
    //d第一种写法
    /* for (i in stringlist) {
         println(i)
     }
     //第二种写法
     var print = fun(name: String) {
         println(name)
     }
     stringlist.forEach(
         print
     )
     //第三种写法,把参数抽了出来 it就是参数，我们可以直接写函数体
     stringlist.forEach {
         println(it)
     }*/
    println(stringlist.findLast {
        it.equals("a") && it.equals("1")
    })
}

fun add(a: Int,b:Int): Int {
    return a
}

//可变参数 vararg
fun add1(vararg a: Int): Int {
    var result = 0
    a.forEach {
        result += it
    }
    return result
}



package com.thinkwithu.www.kotlindemo

import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import android.widget.Button

class MainActivity : AppCompatActivity() {


    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
    }




}
package com.thinkwithu.www.kotlindemo

/**
 * Copyright (C), 2015-2019, 北京九州申友教育咨询有限公司
 * Author: sean
 * Date: 2019/4/25 17:23
 * Description: ${DESCRIPTION}
 */

fun main() {
    //编译器可以自动识别类型，所以不需要显示传入类型
//    var t1 = generic(8)
//    var t2 = generic<String>("44")
//    t1.dd(78)
//    println(t1.cc)
//    println(t2.cc)
//    printlnn("haha")
//    printlnn(995)
//    printlnn(true)
//    jjj(aaaa())

//    var color = getColor.Red
//    println(getColor.values())
//    println(getColor.valueOf("Blue"))
//    println(color.name)
//    println(color.ordinal)
    /* eatDrink(object : annimal("长颈鹿") {
         override fun eat() {
             super.eat()
             println("$this 在喝水")
         }
     })
     //通过对象表达式，我们可以直接拿到类的对象
     var aa = object : annimal("") {

     }
     var aa1 = object {

     }*/
    val pen1 = pen
    val pen2 = pen
    println(pen1 === pen2)


}

//泛型，即参数化类型，把类型参数化，就和实参一样，一开始我们不知道要传什么类型的参数，所以就用一个参数来代替这个类型，
//当我们准备传入参数的时候，在把类型带上去，是为了避免之后的代码出现问题，这样的话 我们需要string类型，就必须传string，传int就会报错，能从编译期解决类型转换报错的问题

class generic<T>(a: T) {
    val cc = a
    fun dd(r: T) {
        println(r)
    }
}


//泛型函数

fun <T> printlnn(value: T) {
    when (value) {
        is Int -> println("传过来的是整形数字$value")
        is String -> println("穿过来的是字符串${value.reversed()}")
        else -> println("啥也不是")
    }
}

//泛型约束

open class aaa
interface bbb


fun <T : aaa> haha(value: T) {

}

class aaaa : aaa(), bbb

//多个条件的泛型约束，使用where语句，并且只能有一个条件是类，其余都可以是接口
//where语句，多个条件同时满足，才能传这个类型，相当于&&
fun <T> jjj(value: T)
        where T : aaa,
              T : bbb {

}


//枚举类用enum修饰，当一个类的对象固定且有限时使用枚举类，可以达到类型安全的意义
enum class getColor {
    Red(), Blue(), White()
}

//对象表达式，对一个类作了轻微的改变，比如增加了某些功能，但却不需要新建子类，有点装饰器的味道，用object修饰
//就是java中的匿名内部类

open class annimal(var string: String) {
    open fun eat() {
        println("$string 在吃早饭")
    }
}

fun eatDrink(a: annimal) {
    a.eat()
}

//对象声明
//我们使用object来申明一个对象，相当于是拿到了类的实例，并且是单例的，
//相当于，我们可以很便捷的拿到一个对象，绕过了去申明类的过程
var c2c = object : annimal("a") {

}

fun text3() {
    c2c.eat()

}


object pen {
    fun write() {
        println("我在写字")
    }
}

//可以有父类，其实相当于是pencil 继承了父类，并且还得到了pencil类的对象，
//同时做了两个步骤，继承了父类，和实例化了对象
object pencil : annimal("劳资") {


}

class outer {
    var name = "wo"

    object inner {
        fun innerDo() {
//            println(name)  当声明对象在一个类的内部时，并不能访问到外部类的成员
        }

    }
}

var o = outer()
fun text1() {
//    println(o.inner) 外部类不能通过它的实例访问到这个对象
    outer.inner.innerDo()//只能通过类名直接访问
}


//伴生对象，从名字看，我们就可以看出来相当于这个对象是伴随着其他东西依托存在的
//用companion修饰，

class floor {
    companion object inner { //其实就是在类 内部的对象声明加了companion关键字，使得inner成了伴生对象
        fun innerDo() {

        }
    }
}

fun text4() {
    floor.innerDo() //伴生对象的成员可以被外部类直接访问，有点静态属性的味道，可以通过类名可以得到
}

class phone {
    companion object {  //我们可以省略掉伴生对象的名字，因为这个名字其实没多大意义
        fun dosomthing() {
            println("do")
        }
    }
}

fun text5() {
    val phone1 = phone.Companion  //我们可以通过类.companion拿到伴生对象，由此可以看出我们类的伴生对象只能有一个，即companion关键字只能用一次
    phone1.dosomthing()
}




























package com.thinkwithu.www.kotlindemo.weituo

/**
 * Author: sean
 * Date: 2019/5/6 11:33
 */
class Biaodi : Xiwan {
    override fun washing() {
        println("表弟不耐烦在洗碗")
    }

    var a = 4 + 5
    operator fun plus(a: Int) {

    }

    var cc = "aa"
        set(value) {
            field = "99"
        }


}package com.thinkwithu.www.kotlindemo.weituo

/**
 * Author: sean
 * Date: 2019/5/6 11:32
 */
class Me : Xiwan by Biaodi() {
}package com.thinkwithu.www.kotlindemo.weituo

/**
 * Author: sean
 * Date: 2019/5/6 11:33
 */

fun main() {
    var me = Me()
    me.washing()
}package com.thinkwithu.www.kotlindemo.weituo

/**
 * Author: sean
 * Date: 2019/5/6 11:31
 */
interface Xiwan {
    fun washing()
}package com.thinkwithu.www.kotlindemo

import org.junit.Test

import org.junit.Assert.*

/**
 * Example local unit test, which will execute on the development machine (host).
 *
 * See [testing documentation](http://d.android.com/tools/testing).
 */
class ExampleUnitTest {
    @Test
    fun addition_isCorrect() {
        assertEquals(4, 2 + 2)
    }
}
package com.thinkwithu.www.kotlindemo

import androidx.test.InstrumentationRegistry
import androidx.test.runner.AndroidJUnit4

import org.junit.Test
import org.junit.runner.RunWith

import org.junit.Assert.*

/**
 * Instrumented test, which will execute on an Android device.
 *
 * See [testing documentation](http://d.android.com/tools/testing).
 */
@RunWith(AndroidJUnit4::class)
class ExampleInstrumentedTest {
    @Test
    fun useAppContext() {
        // Context of the app under test.
        val appContext = InstrumentationRegistry.getTargetContext()
        assertEquals("com.thinkwithu.www.kotlindemo", appContext.packageName)
    }
}
package com.thinkwithu.www.kotlindemo

import java.lang.Exception
import java.lang.IndexOutOfBoundsException
import java.lang.NumberFormatException

/**
 * Copyright (C), 2015-2019, 北京九州申友教育咨询有限公司
 * Author: sean
 * Date: 2019/4/18 16:14
 * Description: ${DESCRIPTION}
 */
fun main() {
//    basictype()
    var argus = arrayOf(5, 10)
//    bianli(argus)
//    abnormal(argus);
//    expression(argus)
//    parameter(4, 4, a = "1")
//    change("a", "b", "v")
//    string()
//    nullText()
//    range()
//    compare()
//    char('5')
//    array(intArrayOf(5, 8))
    string("hello")
}


/**
 * 基本数据类型
 */
fun basictype() {
    //数字：Double,Float,Long,Int,Short,Byte
    var INta = 1 //可以不用指定类型，使用时会自动判断类型
    var LongA = 5L//长整型，用L标记
    var OXA = 0Xff//十六进制，以0x开头标记
    var ObA = 0b1011//二进制，以0b开头
    //不支持8进制
    var DoubleA = 6.55//默认是double类型
    var FloatA = 6.5f//单精度以f结尾
    var oneMillion = 1_000_000//以下划线分割，易读
}

/**
 *  for 循环
 */
fun bianli(argus: ArrayList<String>) {
    for (value in argus) {
        println(value)
    }
    for ((index, value) in argus.withIndex()) {
        println("$index->$value")
    }
    for (indexvalue in argus.withIndex()) {
        println(indexvalue)
    }

}

/**
 * 异常处理
 */

fun abnormal(argus: Array<String>) {
    try {
        var a = argus[0]
        var b = argus[1]
        var c = a.toInt() + b.toInt()
        print(c)
    } catch (e: NumberFormatException) {
        println("您给的是整数吗")
    } catch (e: IndexOutOfBoundsException) {
        println("您给的是两个整数吗")
    } finally {
        println("谢谢使用")
    }

}

/**
 * 表达式
 */
fun expression(argus: Array<Int>) {
    var a = try {
        argus[0].toInt() / argus[1].toInt()
    } catch (e: Exception) {
        e.printStackTrace()
    } finally {
        println("我是表达式")
    }
    println(a)
}

/**
 *vararg修饰变长参数
 * 具名参数
 * 默认参数
 */
fun parameter(vararg ints: Int, a: String, c: Double = 5.2) {
    for (b in ints) println(b)
    println(a)
    println(c)
}

//函数以fun关键字修饰，参数是以变量：类型形式，返回值是以;类型写在最后 ，；可以省略
fun func(a: Int, b: String): Int {
    return 1
}

//表达式作为函数体，返回类型自动判断
fun sun(a: Int, b: Int) = a + b

public fun sum(a: Int, b: Int) = a + b

//无返回值，unit可以省略
fun printsum(a: Int, b: Int): Unit {
    println(a + b)
}

fun printsum1(a: Int, b: Int) {
    println(a + b)
}

//可变长参数用vararg显示
fun change(vararg v: String) {
    for (i in v)
        println(v)
    println("b")
    println("vvv")
}

//var 修饰可变变量，
var cc: String = "7"

fun text() {
//编译器自动识别类型
    var aa = 4
    aa += 1
}

//字符串模板 以$符号
fun string() {
    var a = "a"
    var b = "this is $a"
    var c = "this is ${text()}"
    println(b)
    println(c)
}


//null 安全机制
fun nullText() {
    var a: String? = null// ?表示可为空
//    var b = a!!.toInt()//！！表示如果为null则抛出异常
    var c = a?.toInt()//?表示如果为null则返回null
    var d = a?.toInt() ?: -1//?:表示 如果为null则返回-1
    println(a)
//    println(b)
    println(c)
    println(d)
}


fun typeText(obj: Any): Int? {
    if (obj is String) {
        return obj.length  //obj自动转换成String
    }
    return null
}


fun typeText1(obj: Any): Int? {
    if (obj !is String) {
        return null
    }
    return obj.length //obj自动转换String
}

fun typeText2(obj: Any): Int? {
    if (obj is String && obj.length > 0) {//obj自动转换String
        return obj.length
    }
    return null
}

//区间
fun range() {
    for (i in 1..5) println(i)
    for (i in 1..10 step 2) println(i)
    for (i in 4 downTo 1 step 1) println(i)
    for (i in 2 until 7) println(i)
}


//kt没有基础数据类型，只有封装的数字类型
//两个=表示，比较值的大小，三个=表示比较地址
fun compare() {
    val a = 100
    val b: Int? = a
    val c: Int? = a
    println(c == b)
    println(c === b)
}

fun type() {
    var a: Int = 5
    var b: Long = a.toLong()
    var c: String = a.toString()
}

//字符：不能和数字类型直接操作,可以显示转换成数字类型
fun char(c: Char): Int? {
    if (c in '0'..'9') {
        return c.toInt()
    }
    return null
}

//数组，用Array实现，此外还有IntArray,DoubleArray,等等
fun array(ary: IntArray) {
    println(ary.size)
    println(ary[0])
    ary[0] = 100
    println(ary[0])
}

//字符串可以被遍历，用三个"""可以支持换行操作，用trimmargin去掉字符串前面多余的空格，默认是以竖线分割
fun string(a: String) {
    for (s in a) {
        println(s)
    }
    var s1 = """
多行字符串
        支持
多行字符串用三个双引号
    """
    var s2 = """
        5多行字符串
        5支持
        5多行字符串用三个双引号
    """.trimMargin("5")
    println(s1)
    println(s2)
}















































































package com.thinkwithu.www.kotlindemo

/**
 * Copyright (C), 2015-2019, 北京九州申友教育咨询有限公司
 * Author: sean
 * Date: 2019/4/23 17:13
 * Description: ${DESCRIPTION}
 */
fun main() {

    /* var f = FourClass(88)
     f.cc()
     var fi = Five("", 1, "")*/
    /* var a = eight.nine(10).foo()
     println(a)*/
//    var c = C()
//    c.foo()

//    val user = User();
//    user.extension()

    /* val intarray = intArrayOf(4, 9, 6)
     intarray.extecsion()
     for (i in intarray) {
         println(i)
     }*/
//    entity(v())
//    val yn = yun();
//    yn.foo()

//    var a: String? = null
//    println(a.toString())

//    myclass.foo()
//    moon().sunDo(sun(
//    bb().bbDo(aa())
//    pp().dp(tt1())
//    pp1().dp(tt())
    val jack = mydata("jack", 18)
    val oldjack = jack.copy(age = 45)//copy方法对
    println(jack)
    println(oldjack)

}

//类用class修饰，
class FirstClass {
    public var change: Int = 5 //var申明可变变量
    val a: String = "4" //val申明常量，相当于final


    //成员函数
    fun foo() {
        println("foo")
    }


}

class SecondClass constructor(a: String) {
    //类的主构造器，用constructor修饰，如果没有用可见修饰符修饰，那么constructor可以省略
    var firstClass = FirstClass()//我们可以像使用普通方法那样对类进行实例化，kt中没有new关键字
    var b: Int = 4

    //写了主构造器，能写其他构造器就用this代理主构造器
    /*  constructor(username: String, age: Int){
      }
      constructor(b: Int) {
          this.b = b
      }*/


    fun foo() {
        firstClass.change//通过类名.来获取属性及方法
        firstClass.foo()
    }
}

class ThreeClass() {
    var a = 5
        get() {
            return field + 2008//field只能在get和set方法中使用，用来代替变量的value
        }
        set(value) {
            field = value
        }
    var b = 9
        get
        set

    lateinit var c: String//lateinit用来延迟初始化， 不然在声明变量的时候都必须初始化,只能用于变量var
}

class FourClass(var a: Int) { //主构造器里面申明的变量可以在类范围使用

    init { //类的初始化方法，值的初始化放在init方法里面
        println("init  a  的值是$a")
    }

    fun cc() {
        a = 9
        println("cc  a  的值 是$a")
    }
}


class Five(a: Int, c: String) { //主构造函数如果有参数，那么次构造函数也必需接收这些参数，并为主构造函数代理，使用this关键字
    constructor(b: String, a: Int, c: String) : this(a, c) {

    }
}

open class animal(a: Int) { //open修饰的类才能被继承，默认是被final修饰
    open fun foo() { //open修饰的方法才能被重写，默认是final修饰

    }
}

class person : animal(5) {
    //继承用:格式,如果父类有传参构造方法，那么子类必须实现它
    override fun foo() {

    }
}


abstract class six(a: Int) { //abstract修饰抽象类 抽象类不需要用open修饰，也可以被继承
    abstract fun foo() //abstract修饰抽象方法，也可以不用open修饰
}

class seven : six(8) {
    override fun foo() {
        TODO("not implemented") //To change body of created functions use File | Settings | File Templates.
    }
}

class eight() {
    class nine(a: Int) { //调用嵌套类使用：外部类.嵌套类.属性（方法）
        fun foo() = 8
    }
}


class head {
    var a = 100
    fun b() = 99
    inner class foot() { //内部类用inner 修饰，内部类持有外部类的引用，所以能直接访问外部类的属性和方法
        var c = a
        fun d() {
            var e = b()
        }
    }
}

class book : Any() //所有的类都默认继承自any类。


open class Person(name: String)

class student(name: String, height: Int) : Person(name) //子类有主构造函数，则基类必须在主构造函数中立即初始化

class teacher : Person {  //子类没有主构造函数，则必须在每一个次构造函数中,用super关键字实例化父类
    constructor(name: String) : super(name) {

    }

    constructor(height: Int, name: String) : super(name) {

    }

}


open class A {
    open val a = 99 //属性被open修饰，可以被重写
    open fun foo() {
        println("A")
    }
}

interface B {
    fun foo() { //接口的方法默认是open
        println("B")
    }
}

class C : A(), B { //子类c继承A和实现B,如果A和B有相同的方法，则子类C必须重写这个方法，我们可以用super<>关键字调用哪个父类的方法
    override fun foo() {  //kotlin和java一样，也不能多继承
        super<A>.foo()
        super<B>.foo()
    }

    override var a = 100  //val修饰的常量可以被重写成var变量，反之则不行
    fun d() {
        a = 999
    }

}

interface t {
    var a: Int //变量不允许被初始化，只能是抽象的
    fun b()
    fun c() { //方法可以有默认实现
        println("c")
    }

}

interface tf {
    fun b() {
        println("tf b")
    }

    fun c() {
        println("tf  c")
    }

}


class imp : t {  //实现接口，用: ，
    override var a: Int = 5//子类必须重写接口的属性值

    override fun b() { //没有默认实现的方法，必须重写
        TODO("not implemented") //To change body of created functions use File | Settings | File Templates.
    }
}

class imp1 : t, tf {
    override var a: Int = 88

    override fun b() {//重写接口没被实现的方法，必须重写
        super<tf>.b()
    }

    override fun c() {//重写 两个接口都有的方法 必须重写
        super<t>.c()
        super<tf>.c()
    }

}


class User//空类

//作用域在顶级包下
fun User.extension() {//扩展函数  以fun修饰，以类名.方法名进行扩展，对原类不产生任何影响
    println("我是扩展函数")
}

fun IntArray.extecsion() { //有了扩展函数之后 就可以很方便的对系统函数进行扩展了
    var a = this[0]
    this[0] = this[2]
    this[2] = a
}

//扩展函数是静态解析的，并不是接收者类型的虚拟成员,到底执行哪个扩展函数，是由调用者直接决定的，而不是由动态调用者决定，
//换句话说如果是父类调用扩展函数，而子类也有该扩展函数，当传入的对象是子类时，也是有父类执行扩展函数
open class w

class v : w()

fun w.foo() {
    println("我是w的扩展函数")
}

fun v.foo() {
    println("我是v的扩展函数")
}

fun entity(w1: w) {
    w1.foo()
}


//当扩展函数和成员函数相同时，会优先调用成员函数
class yun {
    fun foo() {
        println("成员")
    }
}

fun yun.foo() {
    println("扩展")
}

//null也可以有扩展函数
fun Any?.haha() {

}

//扩展属性 ,只能支持val，由于没有filed，所以不能被初始化，只能显示初始化
//只能定义在类和kt文件中，不允许定义在方法中
val User.to: Int
    get() {
        return 4
    }

fun User.text() {
    val a = 8
    println(this.to)
}


//伴生对象
class myclass {
    companion object {

    }
}

fun myclass.Companion.foo() {
    println("我是伴生对象的扩展方法啊")
}


class sun {
    fun speak() {
        println("我是太阳，在说话")
    }
}


class moon {

    fun hahaa() {
        println("我是月亮的哈哈")
    }

    //当一个类的扩展函数是另一个类的成员函数时，这个函数内既可以调用扩展接受者的成员函数，也可以调用分发接收者的成员函数
    //这个方法的作用域只能在该类中
    fun sun.sing() {
        speak()
        hahaa()
        println("我是太阳，在唱歌")
    }

    fun sunDo(s: sun) {
        s.sing()
    }


}


class aa {
    fun foo() {
        println("aa foo")
    }
}

class bb {
    fun foo() {
        println("bb foo")
    }

    fun aa.other() {
        foo() //当扩展接受者和分发接收者都有同样的方法时，会优先调用扩展接收者
        this@bb.foo()//可以使用this关键字@类名调用分发接收者的方法
        println("other")
    }

    fun bbDo(a: aa) {
        a.other()
    }

}


open class tt

class tt1 : tt()


open class pp {

    open fun tt.dt() {
        println("pp里面的tt")
    }

    open fun tt1.dt() {
        println("pp里面的tt1")
    }

    fun dp(t: tt) { //针对扩展接收者，仍然是静态的，不会因为动态类型而改变
        t.dt()
    }
}


//针对扩展接收者和分发接收者而言，扩展接收者重写之后也是属于静态解析，而分发接收者 则不同
class pp1 : pp() {
    override fun tt.dt() {  //方法被重写了，用pp1去调用也会生效，
        println("pp1 里面的tt")
    }

    override fun tt1.dt() {
        println("pp1 里面的tt1")
    }

}

//数据类 用data 关键字修饰，主构造方法必须有参数，可以用copy方法复制数据对象的数据
data class mydata(val name: String, val age: Int)

























































































package com.thinkwithu.www.kotlindemo

/**
 * Copyright (C), 2015-2019, 北京九州申友教育咨询有限公司
 * Author: sean
 * Date: 2019/4/23 12:02
 * Description: ${DESCRIPTION}
 */

// main方法是kt的进入方法，好比java的main方法
fun main() {
//    conditionif(5, 9);
//    conditionwhen("李四", 5)
//    conditionfor()
    conditionwhile()
}

fun conditionif(a: Int, b: Int) {
    //传统用法
    var max: Int = b
    if (a > b) max = a
    //用if  else
    if (a > b) {
        max = a
    } else {
        max = b
    }
    //if作为表达式，可以进行赋值，取代java的三目运算符
    max = if (a > b) {
        a
    } else {
        b
    }
    max = if (a > b) a else b
    println("max的值是$max")

    if (a in 5..9) {
        println("$a 在区间")
    }
}

//when 相当于增强版的java switch case语句 支持任意类型，不用写break
fun conditionwhen(a: String, b: Int) {
    when (a) {
        "张三" -> println("我是张三")
        "李四" -> println("我是李四")
        else -> println("我是王五")
    }

    when (b) {
        4, 5 -> println("b的值是4或者5")//条件可以写在一起，
        in 1..10 -> println("在区间1到10之间")//支持in  ,!in写法
        !in 50..100 -> println("不在50到100之间")
        is Int -> println("是整型")//支持is  !is写法
    }

    when {
        b == 1 -> println("b的值是1") //不传参，取代if  else 的写法，不传参数
        b == 2 -> println("b的值是2")
        else -> println("b的值不知道是多少")
    }

    var d = when (b) { //when语句作为表达式，可以进行赋值
        1 -> 11
        2 -> 22
        else -> 8
    }
    println(d)
}

fun conditionfor() {
    var a = arrayOf(4, 5, 6)
    for (b in a) {
        println(b)
    }
    for (c in a.withIndex()) {
        println(c)
    }
    for (d in a) {
        if (d == 4) continue //结束本次循环，继续下一次
        if (d == 5) break //跳出循环
    }

    oop@ for (e in a) {  //以名字加上@符号 给表达式取名
        for (j in a) {
            break@oop //跳出最外层循环
        }
    }


}

fun conditionwhile() {
    var a = 0
    while (a > 0) { //满足条件 就会继续执行
        println(--a)
    }
    println("--------------")
    do {
        println(--a)  //先执行一次，在进去while判断
    } while (a > 0)


}









package com.thinkwithu.www.kotlindemo.dsl

/**
 * Author: sean
 * Date: 2019/5/14 11:15
 */

/**
 * <html>
 *     <body>
 *    </body>
</html>
 */

fun main() {
    //高阶函数
    val html = html {
        head {

        }
        body {
            div {

            }
        }

    }
    println(html)
}

fun Body.div(block: () -> Unit) {
    val d=Div()
    setTag(d)
}


fun html(block: Html.() -> Unit): Html {
    val h = Html()
    block(h)
    return h
}

fun Html.body(block:Body.() -> Unit) {
    val b = Body()
    block(b)
    setTag(b)
}

fun Html.head(block: () -> Unit) {
    val h = Head()
    setTag(h)
}


open class Tag(val name: String) {
    val list = ArrayList<Tag>()

    fun setTag(tag: Tag) {
        list.add(tag)
    }

    override fun toString(): String {
        val stringBuilder = StringBuilder()
        stringBuilder.append("<$name>")
        list.forEach { stringBuilder.append(it.toString()) }
        stringBuilder.append("</$name>")
        return stringBuilder.toString()
    }
}

class Html : Tag("html")
class Body : Tag("body")
class Head : Tag("head")
class Div : Tag("div")
package com.thinkwithu.www.kotlindemo.fanxing

/**
 * Author: sean
 * Date: 2019/5/8 10:17
 */

fun main(args: Array<String>) {
    aaa.cc()
}

abstract class annimal

class Dog : annimal()

class cat : annimal()

open class Box<T>(thing: T)

class AnnimalBox(annimal: annimal) : Box<annimal>(annimal)


class aaa() {
    companion object {
        var a = ""
        fun cc() {

        }
    }
}
package com.thinkwithu.www.kotlindemo.fanxing.函数回调

/**
 * Author: sean
 * Date: 2019/5/13 14:51
 */


fun main() {
    val us = usa()
    us.chinesehome({
        it.copy()
    })
}

data class xinpian(var name: String)

class aaa(aaa5: Int) {
}

class aaa1(var int5: Int) {
    fun cc(){
        int5=9
    }
}

class chinese() {
    val us = usa()

}

class usa() {
    fun chinesehome(f: (xinpian) -> Unit) {
        val xinpian = xinpian("小霸王")
        f.invoke(xinpian)
    }
}


package com.thinkwithu.www.kotlindemo.fanxing

/**
 * Author: sean
 * Date: 2019/5/8 16:25
 */


fun main() {
//    danli.instance.name
//    danli.instance.age
//    println(text(C()))
    //获取函数的引用，用::函数名可以获取函数的引用
    /*  println(jisuan(4, 7, ::add))
      //lambda 表达式
      println(jisuan(77, 99, { m, n ->
          println()
          m - n
      }))
      //lambda表达式  去括号  括号前移
      println(jisuan(4, 9) { m, n ->
          m + n
      })*/
  /*  lamba(4)
    //使用lambda的时候，如果参数只有一个，那么可以省略参数不写，默认参数就是it
    jisuan(4, {
        it + 10
    })*/
    var list= listOf<String>("a","b","c")
   /* list.filter {  }*/

}

class danli() {
    var name = "asd"
    val age by lazy {
        5
    }
    //lateinit  不能修饰基本类型
    lateinit var height: String

    companion object {
        val instance by lazy {
            danli()
        }
    }

}


open class A
class B : A()
class C : A()
class D : A()

fun text(a: A): Boolean {
    return when (a) {
        is B -> true
        is D -> true
        else -> false
    }
}


fun add(a: Int, b: Int) = a + b
fun jian(a: Int, b: Int) = a - b

//高阶函数
fun jisuan(a: Int, b: Int, block: (Int, Int) -> Int): Int {
    return block.invoke(a, b)
}

//高阶函数
fun jisuan(a: Int, block: (Int) -> Int): Int {
    return block.invoke(a)
}

val lamba = { a: Int ->
    a
}








package com.thinkwithu.www.kotlindemo.fanxing.四大函数


/**
 * Author: sean
 * Date: 2019/5/13 11:33
 */

fun main(args: Array<String>) {
    val list = arrayListOf<String>("aaa")
    /**
     * 1.任何类型的扩展方法
     * 2.参数是有接收者的函数
     * 返回值是自己
     */
    list.apply {
        add("222")
        add("222")
    }

    /**
     * 1.参数是有一个参数的函数，参数函数的返回值是泛型R
     * 函数的返回值是参数函数的返回值
     */
    list.let {
        it.add("44")
        "ssss"
    }.length

    /**
     * 相当于是apply和let方法的合成题
     * 有两个参数，第一个参数是任意类型，第二个参数是有接收类型的函数，
     * 函数的返回值是第二个函数参数的返回值
     */
    with(8, {
        toString()
        "aaa"
    }).length

    /*
    1.参数是有接收类型的函数，接收类型是调用类型
    函数的返回值是函数参数的返回值
     */
    list.run {
        add("aaa")
        "rrrr"
    }.toString()


}

package com.thinkwithu.www.kotlindemo.heima

import java.lang.Exception
import java.math.BigInteger

/**
 * Copyright (C), 2015-2019, 北京九州申友教育咨询有限公司
 * Author: sean
 * Date: 2019/5/5 10:54
 * Description: ${DESCRIPTION}
 */

//程序的主方法
fun main(argus: Array<String>) {
//    println(sayHello("xiaozhang"))
//    println(checkAge(19))
//    saveLog(1)
//    println(darary("滁洲岛"))
//    qujian()
//    add(3, 2)
//    hanshu()
//    zhouchang(a = 6.3f)
//    jiaohu()
    println(jiecheng(BigInteger("100000")))
}

fun basic1() {
    var a = 5  //智能推断类型  var  可变的数据
    var b: Byte = 9 //显示指定类型
    var c: Int //指定类型，可以被重新赋值
    c = 99
    val number = "No.123598" //val 是常量，不能被修改，只读数据，确定了就不能被修改
//    number = "sdfdf"

    var d: Boolean
    d = 5 > 4

}


fun sayHello(name: String): String {
    return name
}

fun checkAge(age: Int): Boolean {
    return age > 18
}

fun saveLog(logLeavel: Int) {
    println(logLeavel)
}


//字符串模板    用$符号
fun darary(place: String): String {
    var comtent = """
        今天我去了${place}这里游玩，真好玩
    """.trimIndent()
    return comtent
}


fun qujian() {
    var a = 1..100000
    var result: Int = 0
    for (c in a) {
        result = result + c
    }
    println(result)
}

fun add(a: Int, b: Int) = a + b

fun hanshu() {
    var a = { x: Int, y: Int -> x + y }
    var b: (Int, Int) -> Int = { x, y -> x + y }
    var resule = a(3, 6)
    println(resule)
}


fun zhouchang(pi: Float = 3.14f, a: Float): Float = a * pi


fun jiaohu() {
    while (true) {
        try {
            println("********************************")
            println("请输入第一个数字")
            var a = readLine()!!.toInt()
            println("请输入第二个数字")
            var b = readLine()!!.toInt()
            println("$a + $b =${a + b}")
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }
}



// tailrec  尾递归 优化   不管多少次都要执行
tailrec fun  jiecheng(a: BigInteger): BigInteger {
    println(100000 - a.toInt())
    if (a == BigInteger.ONE) {
        return BigInteger.ONE
    } else {
        return jiecheng(a - BigInteger.ONE)
    }
}





















package com.thinkwithu.www.kotlindemo.heima26

/**
 * Author: sean
 * Date: 2019/5/5 17:36
 */

fun main(args: Array<String>) {
//    han_shu_shi()
    //::函数名，用于声明函数对象
    var add = ::add
    //有两种方式，函数对象的调用，
    println(add(1, 2))
    //这种方式更加安全
    println(add?.invoke(1, 2))


}

fun han_shu_shi() {
    var stringlist = listOf<String>("a", "b", "c")
    //d第一种写法
    /* for (i in stringlist) {
         println(i)
     }
     //第二种写法
     var print = fun(name: String) {
         println(name)
     }
     stringlist.forEach(
         print
     )
     //第三种写法,把参数抽了出来 it就是参数，我们可以直接写函数体
     stringlist.forEach {
         println(it)
     }*/
    println(stringlist.findLast {
        it.equals("a") && it.equals("1")
    })
}

fun add(a: Int,b:Int): Int {
    return a
}

//可变参数 vararg
fun add1(vararg a: Int): Int {
    var result = 0
    a.forEach {
        result += it
    }
    return result
}



package com.thinkwithu.www.kotlindemo

import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import android.widget.Button

class MainActivity : AppCompatActivity() {


    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
    }




}
package com.thinkwithu.www.kotlindemo

/**
 * Copyright (C), 2015-2019, 北京九州申友教育咨询有限公司
 * Author: sean
 * Date: 2019/4/25 17:23
 * Description: ${DESCRIPTION}
 */

fun main() {
    //编译器可以自动识别类型，所以不需要显示传入类型
//    var t1 = generic(8)
//    var t2 = generic<String>("44")
//    t1.dd(78)
//    println(t1.cc)
//    println(t2.cc)
//    printlnn("haha")
//    printlnn(995)
//    printlnn(true)
//    jjj(aaaa())

//    var color = getColor.Red
//    println(getColor.values())
//    println(getColor.valueOf("Blue"))
//    println(color.name)
//    println(color.ordinal)
    /* eatDrink(object : annimal("长颈鹿") {
         override fun eat() {
             super.eat()
             println("$this 在喝水")
         }
     })
     //通过对象表达式，我们可以直接拿到类的对象
     var aa = object : annimal("") {

     }
     var aa1 = object {

     }*/
    val pen1 = pen
    val pen2 = pen
    println(pen1 === pen2)


}

//泛型，即参数化类型，把类型参数化，就和实参一样，一开始我们不知道要传什么类型的参数，所以就用一个参数来代替这个类型，
//当我们准备传入参数的时候，在把类型带上去，是为了避免之后的代码出现问题，这样的话 我们需要string类型，就必须传string，传int就会报错，能从编译期解决类型转换报错的问题

class generic<T>(a: T) {
    val cc = a
    fun dd(r: T) {
        println(r)
    }
}


//泛型函数

fun <T> printlnn(value: T) {
    when (value) {
        is Int -> println("传过来的是整形数字$value")
        is String -> println("穿过来的是字符串${value.reversed()}")
        else -> println("啥也不是")
    }
}

//泛型约束

open class aaa
interface bbb


fun <T : aaa> haha(value: T) {

}

class aaaa : aaa(), bbb

//多个条件的泛型约束，使用where语句，并且只能有一个条件是类，其余都可以是接口
//where语句，多个条件同时满足，才能传这个类型，相当于&&
fun <T> jjj(value: T)
        where T : aaa,
              T : bbb {

}


//枚举类用enum修饰，当一个类的对象固定且有限时使用枚举类，可以达到类型安全的意义
enum class getColor {
    Red(), Blue(), White()
}

//对象表达式，对一个类作了轻微的改变，比如增加了某些功能，但却不需要新建子类，有点装饰器的味道，用object修饰
//就是java中的匿名内部类

open class annimal(var string: String) {
    open fun eat() {
        println("$string 在吃早饭")
    }
}

fun eatDrink(a: annimal) {
    a.eat()
}

//对象声明
//我们使用object来申明一个对象，相当于是拿到了类的实例，并且是单例的，
//相当于，我们可以很便捷的拿到一个对象，绕过了去申明类的过程
var c2c = object : annimal("a") {

}

fun text3() {
    c2c.eat()

}


object pen {
    fun write() {
        println("我在写字")
    }
}

//可以有父类，其实相当于是pencil 继承了父类，并且还得到了pencil类的对象，
//同时做了两个步骤，继承了父类，和实例化了对象
object pencil : annimal("劳资") {


}

class outer {
    var name = "wo"

    object inner {
        fun innerDo() {
//            println(name)  当声明对象在一个类的内部时，并不能访问到外部类的成员
        }

    }
}

var o = outer()
fun text1() {
//    println(o.inner) 外部类不能通过它的实例访问到这个对象
    outer.inner.innerDo()//只能通过类名直接访问
}


//伴生对象，从名字看，我们就可以看出来相当于这个对象是伴随着其他东西依托存在的
//用companion修饰，

class floor {
    companion object inner { //其实就是在类 内部的对象声明加了companion关键字，使得inner成了伴生对象
        fun innerDo() {

        }
    }
}

fun text4() {
    floor.innerDo() //伴生对象的成员可以被外部类直接访问，有点静态属性的味道，可以通过类名可以得到
}

class phone {
    companion object {  //我们可以省略掉伴生对象的名字，因为这个名字其实没多大意义
        fun dosomthing() {
            println("do")
        }
    }
}

fun text5() {
    val phone1 = phone.Companion  //我们可以通过类.companion拿到伴生对象，由此可以看出我们类的伴生对象只能有一个，即companion关键字只能用一次
    phone1.dosomthing()
}




























package com.thinkwithu.www.kotlindemo.weituo

/**
 * Author: sean
 * Date: 2019/5/6 11:33
 */
class Biaodi : Xiwan {
    override fun washing() {
        println("表弟不耐烦在洗碗")
    }

    var a = 4 + 5
    operator fun plus(a: Int) {

    }

    var cc = "aa"
        set(value) {
            field = "99"
        }


}package com.thinkwithu.www.kotlindemo.weituo

/**
 * Author: sean
 * Date: 2019/5/6 11:32
 */
class Me : Xiwan by Biaodi() {
}package com.thinkwithu.www.kotlindemo.weituo

/**
 * Author: sean
 * Date: 2019/5/6 11:33
 */

fun main() {
    var me = Me()
    me.washing()
}package com.thinkwithu.www.kotlindemo.weituo

/**
 * Author: sean
 * Date: 2019/5/6 11:31
 */
interface Xiwan {
    fun washing()
}package com.thinkwithu.www.kotlindemo

import org.junit.Test

import org.junit.Assert.*

/**
 * Example local unit test, which will execute on the development machine (host).
 *
 * See [testing documentation](http://d.android.com/tools/testing).
 */
class ExampleUnitTest {
    @Test
    fun addition_isCorrect() {
        assertEquals(4, 2 + 2)
    }
}
package com.thinkwithu.www.kotlindemo

import androidx.test.InstrumentationRegistry
import androidx.test.runner.AndroidJUnit4

import org.junit.Test
import org.junit.runner.RunWith

import org.junit.Assert.*

/**
 * Instrumented test, which will execute on an Android device.
 *
 * See [testing documentation](http://d.android.com/tools/testing).
 */
@RunWith(AndroidJUnit4::class)
class ExampleInstrumentedTest {
    @Test
    fun useAppContext() {
        // Context of the app under test.
        val appContext = InstrumentationRegistry.getTargetContext()
        assertEquals("com.thinkwithu.www.kotlindemo", appContext.packageName)
    }
}
package com.thinkwithu.www.kotlindemo

import java.lang.Exception
import java.lang.IndexOutOfBoundsException
import java.lang.NumberFormatException

/**
 * Copyright (C), 2015-2019, 北京九州申友教育咨询有限公司
 * Author: sean
 * Date: 2019/4/18 16:14
 * Description: ${DESCRIPTION}
 */
fun main() {
//    basictype()
    var argus = arrayOf(5, 10)
//    bianli(argus)
//    abnormal(argus);
//    expression(argus)
//    parameter(4, 4, a = "1")
//    change("a", "b", "v")
//    string()
//    nullText()
//    range()
//    compare()
//    char('5')
//    array(intArrayOf(5, 8))
    string("hello")
}


/**
 * 基本数据类型
 */
fun basictype() {
    //数字：Double,Float,Long,Int,Short,Byte
    var INta = 1 //可以不用指定类型，使用时会自动判断类型
    var LongA = 5L//长整型，用L标记
    var OXA = 0Xff//十六进制，以0x开头标记
    var ObA = 0b1011//二进制，以0b开头
    //不支持8进制
    var DoubleA = 6.55//默认是double类型
    var FloatA = 6.5f//单精度以f结尾
    var oneMillion = 1_000_000//以下划线分割，易读
}

/**
 *  for 循环
 */
fun bianli(argus: ArrayList<String>) {
    for (value in argus) {
        println(value)
    }
    for ((index, value) in argus.withIndex()) {
        println("$index->$value")
    }
    for (indexvalue in argus.withIndex()) {
        println(indexvalue)
    }

}

/**
 * 异常处理
 */

fun abnormal(argus: Array<String>) {
    try {
        var a = argus[0]
        var b = argus[1]
        var c = a.toInt() + b.toInt()
        print(c)
    } catch (e: NumberFormatException) {
        println("您给的是整数吗")
    } catch (e: IndexOutOfBoundsException) {
        println("您给的是两个整数吗")
    } finally {
        println("谢谢使用")
    }

}

/**
 * 表达式
 */
fun expression(argus: Array<Int>) {
    var a = try {
        argus[0].toInt() / argus[1].toInt()
    } catch (e: Exception) {
        e.printStackTrace()
    } finally {
        println("我是表达式")
    }
    println(a)
}

/**
 *vararg修饰变长参数
 * 具名参数
 * 默认参数
 */
fun parameter(vararg ints: Int, a: String, c: Double = 5.2) {
    for (b in ints) println(b)
    println(a)
    println(c)
}

//函数以fun关键字修饰，参数是以变量：类型形式，返回值是以;类型写在最后 ，；可以省略
fun func(a: Int, b: String): Int {
    return 1
}

//表达式作为函数体，返回类型自动判断
fun sun(a: Int, b: Int) = a + b

public fun sum(a: Int, b: Int) = a + b

//无返回值，unit可以省略
fun printsum(a: Int, b: Int): Unit {
    println(a + b)
}

fun printsum1(a: Int, b: Int) {
    println(a + b)
}

//可变长参数用vararg显示
fun change(vararg v: String) {
    for (i in v)
        println(v)
    println("b")
    println("vvv")
}

//var 修饰可变变量，
var cc: String = "7"

fun text() {
//编译器自动识别类型
    var aa = 4
    aa += 1
}

//字符串模板 以$符号
fun string() {
    var a = "a"
    var b = "this is $a"
    var c = "this is ${text()}"
    println(b)
    println(c)
}


//null 安全机制
fun nullText() {
    var a: String? = null// ?表示可为空
//    var b = a!!.toInt()//！！表示如果为null则抛出异常
    var c = a?.toInt()//?表示如果为null则返回null
    var d = a?.toInt() ?: -1//?:表示 如果为null则返回-1
    println(a)
//    println(b)
    println(c)
    println(d)
}


fun typeText(obj: Any): Int? {
    if (obj is String) {
        return obj.length  //obj自动转换成String
    }
    return null
}


fun typeText1(obj: Any): Int? {
    if (obj !is String) {
        return null
    }
    return obj.length //obj自动转换String
}

fun typeText2(obj: Any): Int? {
    if (obj is String && obj.length > 0) {//obj自动转换String
        return obj.length
    }
    return null
}

//区间
fun range() {
    for (i in 1..5) println(i)
    for (i in 1..10 step 2) println(i)
    for (i in 4 downTo 1 step 1) println(i)
    for (i in 2 until 7) println(i)
}


//kt没有基础数据类型，只有封装的数字类型
//两个=表示，比较值的大小，三个=表示比较地址
fun compare() {
    val a = 100
    val b: Int? = a
    val c: Int? = a
    println(c == b)
    println(c === b)
}

fun type() {
    var a: Int = 5
    var b: Long = a.toLong()
    var c: String = a.toString()
}

//字符：不能和数字类型直接操作,可以显示转换成数字类型
fun char(c: Char): Int? {
    if (c in '0'..'9') {
        return c.toInt()
    }
    return null
}

//数组，用Array实现，此外还有IntArray,DoubleArray,等等
fun array(ary: IntArray) {
    println(ary.size)
    println(ary[0])
    ary[0] = 100
    println(ary[0])
}

//字符串可以被遍历，用三个"""可以支持换行操作，用trimmargin去掉字符串前面多余的空格，默认是以竖线分割
fun string(a: String) {
    for (s in a) {
        println(s)
    }
    var s1 = """
多行字符串
        支持
多行字符串用三个双引号
    """
    var s2 = """
        5多行字符串
        5支持
        5多行字符串用三个双引号
    """.trimMargin("5")
    println(s1)
    println(s2)
}















































































package com.thinkwithu.www.kotlindemo

/**
 * Copyright (C), 2015-2019, 北京九州申友教育咨询有限公司
 * Author: sean
 * Date: 2019/4/23 17:13
 * Description: ${DESCRIPTION}
 */
fun main() {

    /* var f = FourClass(88)
     f.cc()
     var fi = Five("", 1, "")*/
    /* var a = eight.nine(10).foo()
     println(a)*/
//    var c = C()
//    c.foo()

//    val user = User();
//    user.extension()

    /* val intarray = intArrayOf(4, 9, 6)
     intarray.extecsion()
     for (i in intarray) {
         println(i)
     }*/
//    entity(v())
//    val yn = yun();
//    yn.foo()

//    var a: String? = null
//    println(a.toString())

//    myclass.foo()
//    moon().sunDo(sun(
//    bb().bbDo(aa())
//    pp().dp(tt1())
//    pp1().dp(tt())
    val jack = mydata("jack", 18)
    val oldjack = jack.copy(age = 45)//copy方法对
    println(jack)
    println(oldjack)

}

//类用class修饰，
class FirstClass {
    public var change: Int = 5 //var申明可变变量
    val a: String = "4" //val申明常量，相当于final


    //成员函数
    fun foo() {
        println("foo")
    }


}

class SecondClass constructor(a: String) {
    //类的主构造器，用constructor修饰，如果没有用可见修饰符修饰，那么constructor可以省略
    var firstClass = FirstClass()//我们可以像使用普通方法那样对类进行实例化，kt中没有new关键字
    var b: Int = 4

    //写了主构造器，能写其他构造器就用this代理主构造器
    /*  constructor(username: String, age: Int){
      }
      constructor(b: Int) {
          this.b = b
      }*/


    fun foo() {
        firstClass.change//通过类名.来获取属性及方法
        firstClass.foo()
    }
}

class ThreeClass() {
    var a = 5
        get() {
            return field + 2008//field只能在get和set方法中使用，用来代替变量的value
        }
        set(value) {
            field = value
        }
    var b = 9
        get
        set

    lateinit var c: String//lateinit用来延迟初始化， 不然在声明变量的时候都必须初始化,只能用于变量var
}

class FourClass(var a: Int) { //主构造器里面申明的变量可以在类范围使用

    init { //类的初始化方法，值的初始化放在init方法里面
        println("init  a  的值是$a")
    }

    fun cc() {
        a = 9
        println("cc  a  的值 是$a")
    }
}


class Five(a: Int, c: String) { //主构造函数如果有参数，那么次构造函数也必需接收这些参数，并为主构造函数代理，使用this关键字
    constructor(b: String, a: Int, c: String) : this(a, c) {

    }
}

open class animal(a: Int) { //open修饰的类才能被继承，默认是被final修饰
    open fun foo() { //open修饰的方法才能被重写，默认是final修饰

    }
}

class person : animal(5) {
    //继承用:格式,如果父类有传参构造方法，那么子类必须实现它
    override fun foo() {

    }
}


abstract class six(a: Int) { //abstract修饰抽象类 抽象类不需要用open修饰，也可以被继承
    abstract fun foo() //abstract修饰抽象方法，也可以不用open修饰
}

class seven : six(8) {
    override fun foo() {
        TODO("not implemented") //To change body of created functions use File | Settings | File Templates.
    }
}

class eight() {
    class nine(a: Int) { //调用嵌套类使用：外部类.嵌套类.属性（方法）
        fun foo() = 8
    }
}


class head {
    var a = 100
    fun b() = 99
    inner class foot() { //内部类用inner 修饰，内部类持有外部类的引用，所以能直接访问外部类的属性和方法
        var c = a
        fun d() {
            var e = b()
        }
    }
}

class book : Any() //所有的类都默认继承自any类。


open class Person(name: String)

class student(name: String, height: Int) : Person(name) //子类有主构造函数，则基类必须在主构造函数中立即初始化

class teacher : Person {  //子类没有主构造函数，则必须在每一个次构造函数中,用super关键字实例化父类
    constructor(name: String) : super(name) {

    }

    constructor(height: Int, name: String) : super(name) {

    }

}


open class A {
    open val a = 99 //属性被open修饰，可以被重写
    open fun foo() {
        println("A")
    }
}

interface B {
    fun foo() { //接口的方法默认是open
        println("B")
    }
}

class C : A(), B { //子类c继承A和实现B,如果A和B有相同的方法，则子类C必须重写这个方法，我们可以用super<>关键字调用哪个父类的方法
    override fun foo() {  //kotlin和java一样，也不能多继承
        super<A>.foo()
        super<B>.foo()
    }

    override var a = 100  //val修饰的常量可以被重写成var变量，反之则不行
    fun d() {
        a = 999
    }

}

interface t {
    var a: Int //变量不允许被初始化，只能是抽象的
    fun b()
    fun c() { //方法可以有默认实现
        println("c")
    }

}

interface tf {
    fun b() {
        println("tf b")
    }

    fun c() {
        println("tf  c")
    }

}


class imp : t {  //实现接口，用: ，
    override var a: Int = 5//子类必须重写接口的属性值

    override fun b() { //没有默认实现的方法，必须重写
        TODO("not implemented") //To change body of created functions use File | Settings | File Templates.
    }
}

class imp1 : t, tf {
    override var a: Int = 88

    override fun b() {//重写接口没被实现的方法，必须重写
        super<tf>.b()
    }

    override fun c() {//重写 两个接口都有的方法 必须重写
        super<t>.c()
        super<tf>.c()
    }

}


class User//空类

//作用域在顶级包下
fun User.extension() {//扩展函数  以fun修饰，以类名.方法名进行扩展，对原类不产生任何影响
    println("我是扩展函数")
}

fun IntArray.extecsion() { //有了扩展函数之后 就可以很方便的对系统函数进行扩展了
    var a = this[0]
    this[0] = this[2]
    this[2] = a
}

//扩展函数是静态解析的，并不是接收者类型的虚拟成员,到底执行哪个扩展函数，是由调用者直接决定的，而不是由动态调用者决定，
//换句话说如果是父类调用扩展函数，而子类也有该扩展函数，当传入的对象是子类时，也是有父类执行扩展函数
open class w

class v : w()

fun w.foo() {
    println("我是w的扩展函数")
}

fun v.foo() {
    println("我是v的扩展函数")
}

fun entity(w1: w) {
    w1.foo()
}


//当扩展函数和成员函数相同时，会优先调用成员函数
class yun {
    fun foo() {
        println("成员")
    }
}

fun yun.foo() {
    println("扩展")
}

//null也可以有扩展函数
fun Any?.haha() {

}

//扩展属性 ,只能支持val，由于没有filed，所以不能被初始化，只能显示初始化
//只能定义在类和kt文件中，不允许定义在方法中
val User.to: Int
    get() {
        return 4
    }

fun User.text() {
    val a = 8
    println(this.to)
}


//伴生对象
class myclass {
    companion object {

    }
}

fun myclass.Companion.foo() {
    println("我是伴生对象的扩展方法啊")
}


class sun {
    fun speak() {
        println("我是太阳，在说话")
    }
}


class moon {

    fun hahaa() {
        println("我是月亮的哈哈")
    }

    //当一个类的扩展函数是另一个类的成员函数时，这个函数内既可以调用扩展接受者的成员函数，也可以调用分发接收者的成员函数
    //这个方法的作用域只能在该类中
    fun sun.sing() {
        speak()
        hahaa()
        println("我是太阳，在唱歌")
    }

    fun sunDo(s: sun) {
        s.sing()
    }


}


class aa {
    fun foo() {
        println("aa foo")
    }
}

class bb {
    fun foo() {
        println("bb foo")
    }

    fun aa.other() {
        foo() //当扩展接受者和分发接收者都有同样的方法时，会优先调用扩展接收者
        this@bb.foo()//可以使用this关键字@类名调用分发接收者的方法
        println("other")
    }

    fun bbDo(a: aa) {
        a.other()
    }

}


open class tt

class tt1 : tt()


open class pp {

    open fun tt.dt() {
        println("pp里面的tt")
    }

    open fun tt1.dt() {
        println("pp里面的tt1")
    }

    fun dp(t: tt) { //针对扩展接收者，仍然是静态的，不会因为动态类型而改变
        t.dt()
    }
}


//针对扩展接收者和分发接收者而言，扩展接收者重写之后也是属于静态解析，而分发接收者 则不同
class pp1 : pp() {
    override fun tt.dt() {  //方法被重写了，用pp1去调用也会生效，
        println("pp1 里面的tt")
    }

    override fun tt1.dt() {
        println("pp1 里面的tt1")
    }

}

//数据类 用data 关键字修饰，主构造方法必须有参数，可以用copy方法复制数据对象的数据
data class mydata(val name: String, val age: Int)

























































































package com.thinkwithu.www.kotlindemo

/**
 * Copyright (C), 2015-2019, 北京九州申友教育咨询有限公司
 * Author: sean
 * Date: 2019/4/23 12:02
 * Description: ${DESCRIPTION}
 */

// main方法是kt的进入方法，好比java的main方法
fun main() {
//    conditionif(5, 9);
//    conditionwhen("李四", 5)
//    conditionfor()
    conditionwhile()
}

fun conditionif(a: Int, b: Int) {
    //传统用法
    var max: Int = b
    if (a > b) max = a
    //用if  else
    if (a > b) {
        max = a
    } else {
        max = b
    }
    //if作为表达式，可以进行赋值，取代java的三目运算符
    max = if (a > b) {
        a
    } else {
        b
    }
    max = if (a > b) a else b
    println("max的值是$max")

    if (a in 5..9) {
        println("$a 在区间")
    }
}

//when 相当于增强版的java switch case语句 支持任意类型，不用写break
fun conditionwhen(a: String, b: Int) {
    when (a) {
        "张三" -> println("我是张三")
        "李四" -> println("我是李四")
        else -> println("我是王五")
    }

    when (b) {
        4, 5 -> println("b的值是4或者5")//条件可以写在一起，
        in 1..10 -> println("在区间1到10之间")//支持in  ,!in写法
        !in 50..100 -> println("不在50到100之间")
        is Int -> println("是整型")//支持is  !is写法
    }

    when {
        b == 1 -> println("b的值是1") //不传参，取代if  else 的写法，不传参数
        b == 2 -> println("b的值是2")
        else -> println("b的值不知道是多少")
    }

    var d = when (b) { //when语句作为表达式，可以进行赋值
        1 -> 11
        2 -> 22
        else -> 8
    }
    println(d)
}

fun conditionfor() {
    var a = arrayOf(4, 5, 6)
    for (b in a) {
        println(b)
    }
    for (c in a.withIndex()) {
        println(c)
    }
    for (d in a) {
        if (d == 4) continue //结束本次循环，继续下一次
        if (d == 5) break //跳出循环
    }

    oop@ for (e in a) {  //以名字加上@符号 给表达式取名
        for (j in a) {
            break@oop //跳出最外层循环
        }
    }


}

fun conditionwhile() {
    var a = 0
    while (a > 0) { //满足条件 就会继续执行
        println(--a)
    }
    println("--------------")
    do {
        println(--a)  //先执行一次，在进去while判断
    } while (a > 0)


}









package com.thinkwithu.www.kotlindemo.dsl

/**
 * Author: sean
 * Date: 2019/5/14 11:15
 */

/**
 * <html>
 *     <body>
 *    </body>
</html>
 */

fun main() {
    //高阶函数
    val html = html {
        head {

        }
        body {
            div {

            }
        }

    }
    println(html)
}

fun Body.div(block: () -> Unit) {
    val d=Div()
    setTag(d)
}


fun html(block: Html.() -> Unit): Html {
    val h = Html()
    block(h)
    return h
}

fun Html.body(block:Body.() -> Unit) {
    val b = Body()
    block(b)
    setTag(b)
}

fun Html.head(block: () -> Unit) {
    val h = Head()
    setTag(h)
}


open class Tag(val name: String) {
    val list = ArrayList<Tag>()

    fun setTag(tag: Tag) {
        list.add(tag)
    }

    override fun toString(): String {
        val stringBuilder = StringBuilder()
        stringBuilder.append("<$name>")
        list.forEach { stringBuilder.append(it.toString()) }
        stringBuilder.append("</$name>")
        return stringBuilder.toString()
    }
}

class Html : Tag("html")
class Body : Tag("body")
class Head : Tag("head")
class Div : Tag("div")
package com.thinkwithu.www.kotlindemo.fanxing

/**
 * Author: sean
 * Date: 2019/5/8 10:17
 */

fun main(args: Array<String>) {
    aaa.cc()
}

abstract class annimal

class Dog : annimal()

class cat : annimal()

open class Box<T>(thing: T)

class AnnimalBox(annimal: annimal) : Box<annimal>(annimal)


class aaa() {
    companion object {
        var a = ""
        fun cc() {

        }
    }
}
package com.thinkwithu.www.kotlindemo.fanxing.函数回调

/**
 * Author: sean
 * Date: 2019/5/13 14:51
 */


fun main() {
    val us = usa()
    us.chinesehome({
        it.copy()
    })
}

data class xinpian(var name: String)

class aaa(aaa5: Int) {
}

class aaa1(var int5: Int) {
    fun cc(){
        int5=9
    }
}

class chinese() {
    val us = usa()

}

class usa() {
    fun chinesehome(f: (xinpian) -> Unit) {
        val xinpian = xinpian("小霸王")
        f.invoke(xinpian)
    }
}


package com.thinkwithu.www.kotlindemo.fanxing

/**
 * Author: sean
 * Date: 2019/5/8 16:25
 */


fun main() {
//    danli.instance.name
//    danli.instance.age
//    println(text(C()))
    //获取函数的引用，用::函数名可以获取函数的引用
    /*  println(jisuan(4, 7, ::add))
      //lambda 表达式
      println(jisuan(77, 99, { m, n ->
          println()
          m - n
      }))
      //lambda表达式  去括号  括号前移
      println(jisuan(4, 9) { m, n ->
          m + n
      })*/
  /*  lamba(4)
    //使用lambda的时候，如果参数只有一个，那么可以省略参数不写，默认参数就是it
    jisuan(4, {
        it + 10
    })*/
    var list= listOf<String>("a","b","c")
   /* list.filter {  }*/

}

class danli() {
    var name = "asd"
    val age by lazy {
        5
    }
    //lateinit  不能修饰基本类型
    lateinit var height: String

    companion object {
        val instance by lazy {
            danli()
        }
    }

}


open class A
class B : A()
class C : A()
class D : A()

fun text(a: A): Boolean {
    return when (a) {
        is B -> true
        is D -> true
        else -> false
    }
}


fun add(a: Int, b: Int) = a + b
fun jian(a: Int, b: Int) = a - b

//高阶函数
fun jisuan(a: Int, b: Int, block: (Int, Int) -> Int): Int {
    return block.invoke(a, b)
}

//高阶函数
fun jisuan(a: Int, block: (Int) -> Int): Int {
    return block.invoke(a)
}

val lamba = { a: Int ->
    a
}








package com.thinkwithu.www.kotlindemo

import androidx.test.InstrumentationRegistry
import androidx.test.runner.AndroidJUnit4

import org.junit.Test
import org.junit.runner.RunWith

import org.junit.Assert.*

/**
 * Instrumented test, which will execute on an Android device.
 *
 * See [testing documentation](http://d.android.com/tools/testing).
 */
@RunWith(AndroidJUnit4::class)
class ExampleInstrumentedTest {
    @Test
    fun useAppContext() {
        // Context of the app under test.
        val appContext = InstrumentationRegistry.getTargetContext()
        assertEquals("com.thinkwithu.www.kotlindemo", appContext.packageName)
    }
}
package com.thinkwithu.www.kotlindemo

import java.lang.Exception
import java.lang.IndexOutOfBoundsException
import java.lang.NumberFormatException

/**
 * Copyright (C), 2015-2019, 北京九州申友教育咨询有限公司
 * Author: sean
 * Date: 2019/4/18 16:14
 * Description: ${DESCRIPTION}
 */
fun main() {
//    basictype()
    var argus = arrayOf(5, 10)
//    bianli(argus)
//    abnormal(argus);
//    expression(argus)
//    parameter(4, 4, a = "1")
//    change("a", "b", "v")
//    string()
//    nullText()
//    range()
//    compare()
//    char('5')
//    array(intArrayOf(5, 8))
    string("hello")
}


/**
 * 基本数据类型
 */
fun basictype() {
    //数字：Double,Float,Long,Int,Short,Byte
    var INta = 1 //可以不用指定类型，使用时会自动判断类型
    var LongA = 5L//长整型，用L标记
    var OXA = 0Xff//十六进制，以0x开头标记
    var ObA = 0b1011//二进制，以0b开头
    //不支持8进制
    var DoubleA = 6.55//默认是double类型
    var FloatA = 6.5f//单精度以f结尾
    var oneMillion = 1_000_000//以下划线分割，易读
}

/**
 *  for 循环
 */
fun bianli(argus: ArrayList<String>) {
    for (value in argus) {
        println(value)
    }
    for ((index, value) in argus.withIndex()) {
        println("$index->$value")
    }
    for (indexvalue in argus.withIndex()) {
        println(indexvalue)
    }

}

/**
 * 异常处理
 */

fun abnormal(argus: Array<String>) {
    try {
        var a = argus[0]
        var b = argus[1]
        var c = a.toInt() + b.toInt()
        print(c)
    } catch (e: NumberFormatException) {
        println("您给的是整数吗")
    } catch (e: IndexOutOfBoundsException) {
        println("您给的是两个整数吗")
    } finally {
        println("谢谢使用")
    }

}

/**
 * 表达式
 */
fun expression(argus: Array<Int>) {
    var a = try {
        argus[0].toInt() / argus[1].toInt()
    } catch (e: Exception) {
        e.printStackTrace()
    } finally {
        println("我是表达式")
    }
    println(a)
}

/**
 *vararg修饰变长参数
 * 具名参数
 * 默认参数
 */
fun parameter(vararg ints: Int, a: String, c: Double = 5.2) {
    for (b in ints) println(b)
    println(a)
    println(c)
}

//函数以fun关键字修饰，参数是以变量：类型形式，返回值是以;类型写在最后 ，；可以省略
fun func(a: Int, b: String): Int {
    return 1
}

//表达式作为函数体，返回类型自动判断
fun sun(a: Int, b: Int) = a + b

public fun sum(a: Int, b: Int) = a + b

//无返回值，unit可以省略
fun printsum(a: Int, b: Int): Unit {
    println(a + b)
}

fun printsum1(a: Int, b: Int) {
    println(a + b)
}

//可变长参数用vararg显示
fun change(vararg v: String) {
    for (i in v)
        println(v)
    println("b")
    println("vvv")
}

//var 修饰可变变量，
var cc: String = "7"

fun text() {
//编译器自动识别类型
    var aa = 4
    aa += 1
}

//字符串模板 以$符号
fun string() {
    var a = "a"
    var b = "this is $a"
    var c = "this is ${text()}"
    println(b)
    println(c)
}


//null 安全机制
fun nullText() {
    var a: String? = null// ?表示可为空
//    var b = a!!.toInt()//！！表示如果为null则抛出异常
    var c = a?.toInt()//?表示如果为null则返回null
    var d = a?.toInt() ?: -1//?:表示 如果为null则返回-1
    println(a)
//    println(b)
    println(c)
    println(d)
}


fun typeText(obj: Any): Int? {
    if (obj is String) {
        return obj.length  //obj自动转换成String
    }
    return null
}


fun typeText1(obj: Any): Int? {
    if (obj !is String) {
        return null
    }
    return obj.length //obj自动转换String
}

fun typeText2(obj: Any): Int? {
    if (obj is String && obj.length > 0) {//obj自动转换String
        return obj.length
    }
    return null
}

//区间
fun range() {
    for (i in 1..5) println(i)
    for (i in 1..10 step 2) println(i)
    for (i in 4 downTo 1 step 1) println(i)
    for (i in 2 until 7) println(i)
}


//kt没有基础数据类型，只有封装的数字类型
//两个=表示，比较值的大小，三个=表示比较地址
fun compare() {
    val a = 100
    val b: Int? = a
    val c: Int? = a
    println(c == b)
    println(c === b)
}

fun type() {
    var a: Int = 5
    var b: Long = a.toLong()
    var c: String = a.toString()
}

//字符：不能和数字类型直接操作,可以显示转换成数字类型
fun char(c: Char): Int? {
    if (c in '0'..'9') {
        return c.toInt()
    }
    return null
}

//数组，用Array实现，此外还有IntArray,DoubleArray,等等
fun array(ary: IntArray) {
    println(ary.size)
    println(ary[0])
    ary[0] = 100
    println(ary[0])
}

//字符串可以被遍历，用三个"""可以支持换行操作，用trimmargin去掉字符串前面多余的空格，默认是以竖线分割
fun string(a: String) {
    for (s in a) {
        println(s)
    }
    var s1 = """
多行字符串
        支持
多行字符串用三个双引号
    """
    var s2 = """
        5多行字符串
        5支持
        5多行字符串用三个双引号
    """.trimMargin("5")
    println(s1)
    println(s2)
}















































































package com.thinkwithu.www.kotlindemo

/**
 * Copyright (C), 2015-2019, 北京九州申友教育咨询有限公司
 * Author: sean
 * Date: 2019/4/23 17:13
 * Description: ${DESCRIPTION}
 */
fun main() {

    /* var f = FourClass(88)
     f.cc()
     var fi = Five("", 1, "")*/
    /* var a = eight.nine(10).foo()
     println(a)*/
//    var c = C()
//    c.foo()

//    val user = User();
//    user.extension()

    /* val intarray = intArrayOf(4, 9, 6)
     intarray.extecsion()
     for (i in intarray) {
         println(i)
     }*/
//    entity(v())
//    val yn = yun();
//    yn.foo()

//    var a: String? = null
//    println(a.toString())

//    myclass.foo()
//    moon().sunDo(sun(
//    bb().bbDo(aa())
//    pp().dp(tt1())
//    pp1().dp(tt())
    val jack = mydata("jack", 18)
    val oldjack = jack.copy(age = 45)//copy方法对
    println(jack)
    println(oldjack)

}

//类用class修饰，
class FirstClass {
    public var change: Int = 5 //var申明可变变量
    val a: String = "4" //val申明常量，相当于final


    //成员函数
    fun foo() {
        println("foo")
    }


}

class SecondClass constructor(a: String) {
    //类的主构造器，用constructor修饰，如果没有用可见修饰符修饰，那么constructor可以省略
    var firstClass = FirstClass()//我们可以像使用普通方法那样对类进行实例化，kt中没有new关键字
    var b: Int = 4

    //写了主构造器，能写其他构造器就用this代理主构造器
    /*  constructor(username: String, age: Int){
      }
      constructor(b: Int) {
          this.b = b
      }*/


    fun foo() {
        firstClass.change//通过类名.来获取属性及方法
        firstClass.foo()
    }
}

class ThreeClass() {
    var a = 5
        get() {
            return field + 2008//field只能在get和set方法中使用，用来代替变量的value
        }
        set(value) {
            field = value
        }
    var b = 9
        get
        set

    lateinit var c: String//lateinit用来延迟初始化， 不然在声明变量的时候都必须初始化,只能用于变量var
}

class FourClass(var a: Int) { //主构造器里面申明的变量可以在类范围使用

    init { //类的初始化方法，值的初始化放在init方法里面
        println("init  a  的值是$a")
    }

    fun cc() {
        a = 9
        println("cc  a  的值 是$a")
    }
}


class Five(a: Int, c: String) { //主构造函数如果有参数，那么次构造函数也必需接收这些参数，并为主构造函数代理，使用this关键字
    constructor(b: String, a: Int, c: String) : this(a, c) {

    }
}

open class animal(a: Int) { //open修饰的类才能被继承，默认是被final修饰
    open fun foo() { //open修饰的方法才能被重写，默认是final修饰

    }
}

class person : animal(5) {
    //继承用:格式,如果父类有传参构造方法，那么子类必须实现它
    override fun foo() {

    }
}


abstract class six(a: Int) { //abstract修饰抽象类 抽象类不需要用open修饰，也可以被继承
    abstract fun foo() //abstract修饰抽象方法，也可以不用open修饰
}

class seven : six(8) {
    override fun foo() {
        TODO("not implemented") //To change body of created functions use File | Settings | File Templates.
    }
}

class eight() {
    class nine(a: Int) { //调用嵌套类使用：外部类.嵌套类.属性（方法）
        fun foo() = 8
    }
}


class head {
    var a = 100
    fun b() = 99
    inner class foot() { //内部类用inner 修饰，内部类持有外部类的引用，所以能直接访问外部类的属性和方法
        var c = a
        fun d() {
            var e = b()
        }
    }
}

class book : Any() //所有的类都默认继承自any类。


open class Person(name: String)

class student(name: String, height: Int) : Person(name) //子类有主构造函数，则基类必须在主构造函数中立即初始化

class teacher : Person {  //子类没有主构造函数，则必须在每一个次构造函数中,用super关键字实例化父类
    constructor(name: String) : super(name) {

    }

    constructor(height: Int, name: String) : super(name) {

    }

}


open class A {
    open val a = 99 //属性被open修饰，可以被重写
    open fun foo() {
        println("A")
    }
}

interface B {
    fun foo() { //接口的方法默认是open
        println("B")
    }
}

class C : A(), B { //子类c继承A和实现B,如果A和B有相同的方法，则子类C必须重写这个方法，我们可以用super<>关键字调用哪个父类的方法
    override fun foo() {  //kotlin和java一样，也不能多继承
        super<A>.foo()
        super<B>.foo()
    }

    override var a = 100  //val修饰的常量可以被重写成var变量，反之则不行
    fun d() {
        a = 999
    }

}

interface t {
    var a: Int //变量不允许被初始化，只能是抽象的
    fun b()
    fun c() { //方法可以有默认实现
        println("c")
    }

}

interface tf {
    fun b() {
        println("tf b")
    }

    fun c() {
        println("tf  c")
    }

}


class imp : t {  //实现接口，用: ，
    override var a: Int = 5//子类必须重写接口的属性值

    override fun b() { //没有默认实现的方法，必须重写
        TODO("not implemented") //To change body of created functions use File | Settings | File Templates.
    }
}

class imp1 : t, tf {
    override var a: Int = 88

    override fun b() {//重写接口没被实现的方法，必须重写
        super<tf>.b()
    }

    override fun c() {//重写 两个接口都有的方法 必须重写
        super<t>.c()
        super<tf>.c()
    }

}


class User//空类

//作用域在顶级包下
fun User.extension() {//扩展函数  以fun修饰，以类名.方法名进行扩展，对原类不产生任何影响
    println("我是扩展函数")
}

fun IntArray.extecsion() { //有了扩展函数之后 就可以很方便的对系统函数进行扩展了
    var a = this[0]
    this[0] = this[2]
    this[2] = a
}

//扩展函数是静态解析的，并不是接收者类型的虚拟成员,到底执行哪个扩展函数，是由调用者直接决定的，而不是由动态调用者决定，
//换句话说如果是父类调用扩展函数，而子类也有该扩展函数，当传入的对象是子类时，也是有父类执行扩展函数
open class w

class v : w()

fun w.foo() {
    println("我是w的扩展函数")
}

fun v.foo() {
    println("我是v的扩展函数")
}

fun entity(w1: w) {
    w1.foo()
}


//当扩展函数和成员函数相同时，会优先调用成员函数
class yun {
    fun foo() {
        println("成员")
    }
}

fun yun.foo() {
    println("扩展")
}

//null也可以有扩展函数
fun Any?.haha() {

}

//扩展属性 ,只能支持val，由于没有filed，所以不能被初始化，只能显示初始化
//只能定义在类和kt文件中，不允许定义在方法中
val User.to: Int
    get() {
        return 4
    }

fun User.text() {
    val a = 8
    println(this.to)
}


//伴生对象
class myclass {
    companion object {

    }
}

fun myclass.Companion.foo() {
    println("我是伴生对象的扩展方法啊")
}


class sun {
    fun speak() {
        println("我是太阳，在说话")
    }
}


class moon {

    fun hahaa() {
        println("我是月亮的哈哈")
    }

    //当一个类的扩展函数是另一个类的成员函数时，这个函数内既可以调用扩展接受者的成员函数，也可以调用分发接收者的成员函数
    //这个方法的作用域只能在该类中
    fun sun.sing() {
        speak()
        hahaa()
        println("我是太阳，在唱歌")
    }

    fun sunDo(s: sun) {
        s.sing()
    }


}


class aa {
    fun foo() {
        println("aa foo")
    }
}

class bb {
    fun foo() {
        println("bb foo")
    }

    fun aa.other() {
        foo() //当扩展接受者和分发接收者都有同样的方法时，会优先调用扩展接收者
        this@bb.foo()//可以使用this关键字@类名调用分发接收者的方法
        println("other")
    }

    fun bbDo(a: aa) {
        a.other()
    }

}


open class tt

class tt1 : tt()


open class pp {

    open fun tt.dt() {
        println("pp里面的tt")
    }

    open fun tt1.dt() {
        println("pp里面的tt1")
    }

    fun dp(t: tt) { //针对扩展接收者，仍然是静态的，不会因为动态类型而改变
        t.dt()
    }
}


//针对扩展接收者和分发接收者而言，扩展接收者重写之后也是属于静态解析，而分发接收者 则不同
class pp1 : pp() {
    override fun tt.dt() {  //方法被重写了，用pp1去调用也会生效，
        println("pp1 里面的tt")
    }

    override fun tt1.dt() {
        println("pp1 里面的tt1")
    }

}

//数据类 用data 关键字修饰，主构造方法必须有参数，可以用copy方法复制数据对象的数据
data class mydata(val name: String, val age: Int)

























































































package com.thinkwithu.www.kotlindemo.fanxing.四大函数


/**
 * Author: sean
 * Date: 2019/5/13 11:33
 */

fun main(args: Array<String>) {
    val list = arrayListOf<String>("aaa")
    /**
     * 1.任何类型的扩展方法
     * 2.参数是有接收者的函数
     * 返回值是自己
     */
    list.apply {
        add("222")
        add("222")
    }

    /**
     * 1.参数是有一个参数的函数，参数函数的返回值是泛型R
     * 函数的返回值是参数函数的返回值
     */
    list.let {
        it.add("44")
        "ssss"
    }.length

    /**
     * 相当于是apply和let方法的合成题
     * 有两个参数，第一个参数是任意类型，第二个参数是有接收类型的函数，
     * 函数的返回值是第二个函数参数的返回值
     */
    with(8, {
        toString()
        "aaa"
    }).length

    /*
    1.参数是有接收类型的函数，接收类型是调用类型
    函数的返回值是函数参数的返回值
     */
    list.run {
        add("aaa")
        "rrrr"
    }.toString()


}

package com.thinkwithu.www.kotlindemo

/**
 * Copyright (C), 2015-2019, 北京九州申友教育咨询有限公司
 * Author: sean
 * Date: 2019/4/23 12:02
 * Description: ${DESCRIPTION}
 */

// main方法是kt的进入方法，好比java的main方法
fun main() {
//    conditionif(5, 9);
//    conditionwhen("李四", 5)
//    conditionfor()
    conditionwhile()
}

fun conditionif(a: Int, b: Int) {
    //传统用法
    var max: Int = b
    if (a > b) max = a
    //用if  else
    if (a > b) {
        max = a
    } else {
        max = b
    }
    //if作为表达式，可以进行赋值，取代java的三目运算符
    max = if (a > b) {
        a
    } else {
        b
    }
    max = if (a > b) a else b
    println("max的值是$max")

    if (a in 5..9) {
        println("$a 在区间")
    }
}

//when 相当于增强版的java switch case语句 支持任意类型，不用写break
fun conditionwhen(a: String, b: Int) {
    when (a) {
        "张三" -> println("我是张三")
        "李四" -> println("我是李四")
        else -> println("我是王五")
    }

    when (b) {
        4, 5 -> println("b的值是4或者5")//条件可以写在一起，
        in 1..10 -> println("在区间1到10之间")//支持in  ,!in写法
        !in 50..100 -> println("不在50到100之间")
        is Int -> println("是整型")//支持is  !is写法
    }

    when {
        b == 1 -> println("b的值是1") //不传参，取代if  else 的写法，不传参数
        b == 2 -> println("b的值是2")
        else -> println("b的值不知道是多少")
    }

    var d = when (b) { //when语句作为表达式，可以进行赋值
        1 -> 11
        2 -> 22
        else -> 8
    }
    println(d)
}

fun conditionfor() {
    var a = arrayOf(4, 5, 6)
    for (b in a) {
        println(b)
    }
    for (c in a.withIndex()) {
        println(c)
    }
    for (d in a) {
        if (d == 4) continue //结束本次循环，继续下一次
        if (d == 5) break //跳出循环
    }

    oop@ for (e in a) {  //以名字加上@符号 给表达式取名
        for (j in a) {
            break@oop //跳出最外层循环
        }
    }


}

fun conditionwhile() {
    var a = 0
    while (a > 0) { //满足条件 就会继续执行
        println(--a)
    }
    println("--------------")
    do {
        println(--a)  //先执行一次，在进去while判断
    } while (a > 0)


}









package com.thinkwithu.www.kotlindemo.dsl

/**
 * Author: sean
 * Date: 2019/5/14 11:15
 */

/**
 * <html>
 *     <body>
 *    </body>
</html>
 */

fun main() {
    //高阶函数
    val html = html {
        head {

        }
        body {
            div {

            }
        }

    }
    println(html)
}

fun Body.div(block: () -> Unit) {
    val d=Div()
    setTag(d)
}


fun html(block: Html.() -> Unit): Html {
    val h = Html()
    block(h)
    return h
}

fun Html.body(block:Body.() -> Unit) {
    val b = Body()
    block(b)
    setTag(b)
}

fun Html.head(block: () -> Unit) {
    val h = Head()
    setTag(h)
}


open class Tag(val name: String) {
    val list = ArrayList<Tag>()

    fun setTag(tag: Tag) {
        list.add(tag)
    }

    override fun toString(): String {
        val stringBuilder = StringBuilder()
        stringBuilder.append("<$name>")
        list.forEach { stringBuilder.append(it.toString()) }
        stringBuilder.append("</$name>")
        return stringBuilder.toString()
    }
}

class Html : Tag("html")
class Body : Tag("body")
class Head : Tag("head")
class Div : Tag("div")
package com.thinkwithu.www.kotlindemo.fanxing

/**
 * Author: sean
 * Date: 2019/5/8 10:17
 */

fun main(args: Array<String>) {
    aaa.cc()
}

abstract class annimal

class Dog : annimal()

class cat : annimal()

open class Box<T>(thing: T)

class AnnimalBox(annimal: annimal) : Box<annimal>(annimal)


class aaa() {
    companion object {
        var a = ""
        fun cc() {

        }
    }
}
package com.thinkwithu.www.kotlindemo.heima

import java.lang.Exception
import java.math.BigInteger

/**
 * Copyright (C), 2015-2019, 北京九州申友教育咨询有限公司
 * Author: sean
 * Date: 2019/5/5 10:54
 * Description: ${DESCRIPTION}
 */

//程序的主方法
fun main(argus: Array<String>) {
//    println(sayHello("xiaozhang"))
//    println(checkAge(19))
//    saveLog(1)
//    println(darary("滁洲岛"))
//    qujian()
//    add(3, 2)
//    hanshu()
//    zhouchang(a = 6.3f)
//    jiaohu()
    println(jiecheng(BigInteger("100000")))
}

fun basic1() {
    var a = 5  //智能推断类型  var  可变的数据
    var b: Byte = 9 //显示指定类型
    var c: Int //指定类型，可以被重新赋值
    c = 99
    val number = "No.123598" //val 是常量，不能被修改，只读数据，确定了就不能被修改
//    number = "sdfdf"

    var d: Boolean
    d = 5 > 4

}


fun sayHello(name: String): String {
    return name
}

fun checkAge(age: Int): Boolean {
    return age > 18
}

fun saveLog(logLeavel: Int) {
    println(logLeavel)
}


//字符串模板    用$符号
fun darary(place: String): String {
    var comtent = """
        今天我去了${place}这里游玩，真好玩
    """.trimIndent()
    return comtent
}


fun qujian() {
    var a = 1..100000
    var result: Int = 0
    for (c in a) {
        result = result + c
    }
    println(result)
}

fun add(a: Int, b: Int) = a + b

fun hanshu() {
    var a = { x: Int, y: Int -> x + y }
    var b: (Int, Int) -> Int = { x, y -> x + y }
    var resule = a(3, 6)
    println(resule)
}


fun zhouchang(pi: Float = 3.14f, a: Float): Float = a * pi


fun jiaohu() {
    while (true) {
        try {
            println("********************************")
            println("请输入第一个数字")
            var a = readLine()!!.toInt()
            println("请输入第二个数字")
            var b = readLine()!!.toInt()
            println("$a + $b =${a + b}")
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }
}



// tailrec  尾递归 优化   不管多少次都要执行
tailrec fun  jiecheng(a: BigInteger): BigInteger {
    println(100000 - a.toInt())
    if (a == BigInteger.ONE) {
        return BigInteger.ONE
    } else {
        return jiecheng(a - BigInteger.ONE)
    }
}





















package com.thinkwithu.www.kotlindemo.fanxing.函数回调

/**
 * Author: sean
 * Date: 2019/5/13 14:51
 */


fun main() {
    val us = usa()
    us.chinesehome({
        it.copy()
    })
}

data class xinpian(var name: String)

class aaa(aaa5: Int) {
}

class aaa1(var int5: Int) {
    fun cc(){
        int5=9
    }
}

class chinese() {
    val us = usa()

}

class usa() {
    fun chinesehome(f: (xinpian) -> Unit) {
        val xinpian = xinpian("小霸王")
        f.invoke(xinpian)
    }
}


package com.thinkwithu.www.kotlindemo.heima26

/**
 * Author: sean
 * Date: 2019/5/5 17:36
 */

fun main(args: Array<String>) {
//    han_shu_shi()
    //::函数名，用于声明函数对象
    var add = ::add
    //有两种方式，函数对象的调用，
    println(add(1, 2))
    //这种方式更加安全
    println(add?.invoke(1, 2))


}

fun han_shu_shi() {
    var stringlist = listOf<String>("a", "b", "c")
    //d第一种写法
    /* for (i in stringlist) {
         println(i)
     }
     //第二种写法
     var print = fun(name: String) {
         println(name)
     }
     stringlist.forEach(
         print
     )
     //第三种写法,把参数抽了出来 it就是参数，我们可以直接写函数体
     stringlist.forEach {
         println(it)
     }*/
    println(stringlist.findLast {
        it.equals("a") && it.equals("1")
    })
}

fun add(a: Int,b:Int): Int {
    return a
}

//可变参数 vararg
fun add1(vararg a: Int): Int {
    var result = 0
    a.forEach {
        result += it
    }
    return result
}



package com.thinkwithu.www.kotlindemo.fanxing

/**
 * Author: sean
 * Date: 2019/5/8 16:25
 */


fun main() {
//    danli.instance.name
//    danli.instance.age
//    println(text(C()))
    //获取函数的引用，用::函数名可以获取函数的引用
    /*  println(jisuan(4, 7, ::add))
      //lambda 表达式
      println(jisuan(77, 99, { m, n ->
          println()
          m - n
      }))
      //lambda表达式  去括号  括号前移
      println(jisuan(4, 9) { m, n ->
          m + n
      })*/
  /*  lamba(4)
    //使用lambda的时候，如果参数只有一个，那么可以省略参数不写，默认参数就是it
    jisuan(4, {
        it + 10
    })*/
    var list= listOf<String>("a","b","c")
   /* list.filter {  }*/

}

class danli() {
    var name = "asd"
    val age by lazy {
        5
    }
    //lateinit  不能修饰基本类型
    lateinit var height: String

    companion object {
        val instance by lazy {
            danli()
        }
    }

}


open class A
class B : A()
class C : A()
class D : A()

fun text(a: A): Boolean {
    return when (a) {
        is B -> true
        is D -> true
        else -> false
    }
}


fun add(a: Int, b: Int) = a + b
fun jian(a: Int, b: Int) = a - b

//高阶函数
fun jisuan(a: Int, b: Int, block: (Int, Int) -> Int): Int {
    return block.invoke(a, b)
}

//高阶函数
fun jisuan(a: Int, block: (Int) -> Int): Int {
    return block.invoke(a)
}

val lamba = { a: Int ->
    a
}








package com.thinkwithu.www.kotlindemo

import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import android.widget.Button

class MainActivity : AppCompatActivity() {


    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
    }




}
package com.thinkwithu.www.kotlindemo.fanxing.四大函数


/**
 * Author: sean
 * Date: 2019/5/13 11:33
 */

fun main(args: Array<String>) {
    val list = arrayListOf<String>("aaa")
    /**
     * 1.任何类型的扩展方法
     * 2.参数是有接收者的函数
     * 返回值是自己
     */
    list.apply {
        add("222")
        add("222")
    }

    /**
     * 1.参数是有一个参数的函数，参数函数的返回值是泛型R
     * 函数的返回值是参数函数的返回值
     */
    list.let {
        it.add("44")
        "ssss"
    }.length

    /**
     * 相当于是apply和let方法的合成题
     * 有两个参数，第一个参数是任意类型，第二个参数是有接收类型的函数，
     * 函数的返回值是第二个函数参数的返回值
     */
    with(8, {
        toString()
        "aaa"
    }).length

    /*
    1.参数是有接收类型的函数，接收类型是调用类型
    函数的返回值是函数参数的返回值
     */
    list.run {
        add("aaa")
        "rrrr"
    }.toString()


}

package com.thinkwithu.www.kotlindemo.heima

import java.lang.Exception
import java.math.BigInteger

/**
 * Copyright (C), 2015-2019, 北京九州申友教育咨询有限公司
 * Author: sean
 * Date: 2019/5/5 10:54
 * Description: ${DESCRIPTION}
 */

//程序的主方法
fun main(argus: Array<String>) {
//    println(sayHello("xiaozhang"))
//    println(checkAge(19))
//    saveLog(1)
//    println(darary("滁洲岛"))
//    qujian()
//    add(3, 2)
//    hanshu()
//    zhouchang(a = 6.3f)
//    jiaohu()
    println(jiecheng(BigInteger("100000")))
}

fun basic1() {
    var a = 5  //智能推断类型  var  可变的数据
    var b: Byte = 9 //显示指定类型
    var c: Int //指定类型，可以被重新赋值
    c = 99
    val number = "No.123598" //val 是常量，不能被修改，只读数据，确定了就不能被修改
//    number = "sdfdf"

    var d: Boolean
    d = 5 > 4

}


fun sayHello(name: String): String {
    return name
}

fun checkAge(age: Int): Boolean {
    return age > 18
}

fun saveLog(logLeavel: Int) {
    println(logLeavel)
}


//字符串模板    用$符号
fun darary(place: String): String {
    var comtent = """
        今天我去了${place}这里游玩，真好玩
    """.trimIndent()
    return comtent
}


fun qujian() {
    var a = 1..100000
    var result: Int = 0
    for (c in a) {
        result = result + c
    }
    println(result)
}

fun add(a: Int, b: Int) = a + b

fun hanshu() {
    var a = { x: Int, y: Int -> x + y }
    var b: (Int, Int) -> Int = { x, y -> x + y }
    var resule = a(3, 6)
    println(resule)
}


fun zhouchang(pi: Float = 3.14f, a: Float): Float = a * pi


fun jiaohu() {
    while (true) {
        try {
            println("********************************")
            println("请输入第一个数字")
            var a = readLine()!!.toInt()
            println("请输入第二个数字")
            var b = readLine()!!.toInt()
            println("$a + $b =${a + b}")
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }
}



// tailrec  尾递归 优化   不管多少次都要执行
tailrec fun  jiecheng(a: BigInteger): BigInteger {
    println(100000 - a.toInt())
    if (a == BigInteger.ONE) {
        return BigInteger.ONE
    } else {
        return jiecheng(a - BigInteger.ONE)
    }
}





















package com.thinkwithu.www.kotlindemo

/**
 * Copyright (C), 2015-2019, 北京九州申友教育咨询有限公司
 * Author: sean
 * Date: 2019/4/25 17:23
 * Description: ${DESCRIPTION}
 */

fun main() {
    //编译器可以自动识别类型，所以不需要显示传入类型
//    var t1 = generic(8)
//    var t2 = generic<String>("44")
//    t1.dd(78)
//    println(t1.cc)
//    println(t2.cc)
//    printlnn("haha")
//    printlnn(995)
//    printlnn(true)
//    jjj(aaaa())

//    var color = getColor.Red
//    println(getColor.values())
//    println(getColor.valueOf("Blue"))
//    println(color.name)
//    println(color.ordinal)
    /* eatDrink(object : annimal("长颈鹿") {
         override fun eat() {
             super.eat()
             println("$this 在喝水")
         }
     })
     //通过对象表达式，我们可以直接拿到类的对象
     var aa = object : annimal("") {

     }
     var aa1 = object {

     }*/
    val pen1 = pen
    val pen2 = pen
    println(pen1 === pen2)


}

//泛型，即参数化类型，把类型参数化，就和实参一样，一开始我们不知道要传什么类型的参数，所以就用一个参数来代替这个类型，
//当我们准备传入参数的时候，在把类型带上去，是为了避免之后的代码出现问题，这样的话 我们需要string类型，就必须传string，传int就会报错，能从编译期解决类型转换报错的问题

class generic<T>(a: T) {
    val cc = a
    fun dd(r: T) {
        println(r)
    }
}


//泛型函数

fun <T> printlnn(value: T) {
    when (value) {
        is Int -> println("传过来的是整形数字$value")
        is String -> println("穿过来的是字符串${value.reversed()}")
        else -> println("啥也不是")
    }
}

//泛型约束

open class aaa
interface bbb


fun <T : aaa> haha(value: T) {

}

class aaaa : aaa(), bbb

//多个条件的泛型约束，使用where语句，并且只能有一个条件是类，其余都可以是接口
//where语句，多个条件同时满足，才能传这个类型，相当于&&
fun <T> jjj(value: T)
        where T : aaa,
              T : bbb {

}


//枚举类用enum修饰，当一个类的对象固定且有限时使用枚举类，可以达到类型安全的意义
enum class getColor {
    Red(), Blue(), White()
}

//对象表达式，对一个类作了轻微的改变，比如增加了某些功能，但却不需要新建子类，有点装饰器的味道，用object修饰
//就是java中的匿名内部类

open class annimal(var string: String) {
    open fun eat() {
        println("$string 在吃早饭")
    }
}

fun eatDrink(a: annimal) {
    a.eat()
}

//对象声明
//我们使用object来申明一个对象，相当于是拿到了类的实例，并且是单例的，
//相当于，我们可以很便捷的拿到一个对象，绕过了去申明类的过程
var c2c = object : annimal("a") {

}

fun text3() {
    c2c.eat()

}


object pen {
    fun write() {
        println("我在写字")
    }
}

//可以有父类，其实相当于是pencil 继承了父类，并且还得到了pencil类的对象，
//同时做了两个步骤，继承了父类，和实例化了对象
object pencil : annimal("劳资") {


}

class outer {
    var name = "wo"

    object inner {
        fun innerDo() {
//            println(name)  当声明对象在一个类的内部时，并不能访问到外部类的成员
        }

    }
}

var o = outer()
fun text1() {
//    println(o.inner) 外部类不能通过它的实例访问到这个对象
    outer.inner.innerDo()//只能通过类名直接访问
}


//伴生对象，从名字看，我们就可以看出来相当于这个对象是伴随着其他东西依托存在的
//用companion修饰，

class floor {
    companion object inner { //其实就是在类 内部的对象声明加了companion关键字，使得inner成了伴生对象
        fun innerDo() {

        }
    }
}

fun text4() {
    floor.innerDo() //伴生对象的成员可以被外部类直接访问，有点静态属性的味道，可以通过类名可以得到
}

class phone {
    companion object {  //我们可以省略掉伴生对象的名字，因为这个名字其实没多大意义
        fun dosomthing() {
            println("do")
        }
    }
}

fun text5() {
    val phone1 = phone.Companion  //我们可以通过类.companion拿到伴生对象，由此可以看出我们类的伴生对象只能有一个，即companion关键字只能用一次
    phone1.dosomthing()
}




























package com.thinkwithu.www.kotlindemo.heima26

/**
 * Author: sean
 * Date: 2019/5/5 17:36
 */

fun main(args: Array<String>) {
//    han_shu_shi()
    //::函数名，用于声明函数对象
    var add = ::add
    //有两种方式，函数对象的调用，
    println(add(1, 2))
    //这种方式更加安全
    println(add?.invoke(1, 2))


}

fun han_shu_shi() {
    var stringlist = listOf<String>("a", "b", "c")
    //d第一种写法
    /* for (i in stringlist) {
         println(i)
     }
     //第二种写法
     var print = fun(name: String) {
         println(name)
     }
     stringlist.forEach(
         print
     )
     //第三种写法,把参数抽了出来 it就是参数，我们可以直接写函数体
     stringlist.forEach {
         println(it)
     }*/
    println(stringlist.findLast {
        it.equals("a") && it.equals("1")
    })
}

fun add(a: Int,b:Int): Int {
    return a
}

//可变参数 vararg
fun add1(vararg a: Int): Int {
    var result = 0
    a.forEach {
        result += it
    }
    return result
}



package com.thinkwithu.www.kotlindemo

import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import android.widget.Button

class MainActivity : AppCompatActivity() {


    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
    }




}
package com.thinkwithu.www.kotlindemo.weituo

/**
 * Author: sean
 * Date: 2019/5/6 11:33
 */
class Biaodi : Xiwan {
    override fun washing() {
        println("表弟不耐烦在洗碗")
    }

    var a = 4 + 5
    operator fun plus(a: Int) {

    }

    var cc = "aa"
        set(value) {
            field = "99"
        }


}package com.thinkwithu.www.kotlindemo

/**
 * Copyright (C), 2015-2019, 北京九州申友教育咨询有限公司
 * Author: sean
 * Date: 2019/4/25 17:23
 * Description: ${DESCRIPTION}
 */

fun main() {
    //编译器可以自动识别类型，所以不需要显示传入类型
//    var t1 = generic(8)
//    var t2 = generic<String>("44")
//    t1.dd(78)
//    println(t1.cc)
//    println(t2.cc)
//    printlnn("haha")
//    printlnn(995)
//    printlnn(true)
//    jjj(aaaa())

//    var color = getColor.Red
//    println(getColor.values())
//    println(getColor.valueOf("Blue"))
//    println(color.name)
//    println(color.ordinal)
    /* eatDrink(object : annimal("长颈鹿") {
         override fun eat() {
             super.eat()
             println("$this 在喝水")
         }
     })
     //通过对象表达式，我们可以直接拿到类的对象
     var aa = object : annimal("") {

     }
     var aa1 = object {

     }*/
    val pen1 = pen
    val pen2 = pen
    println(pen1 === pen2)


}

//泛型，即参数化类型，把类型参数化，就和实参一样，一开始我们不知道要传什么类型的参数，所以就用一个参数来代替这个类型，
//当我们准备传入参数的时候，在把类型带上去，是为了避免之后的代码出现问题，这样的话 我们需要string类型，就必须传string，传int就会报错，能从编译期解决类型转换报错的问题

class generic<T>(a: T) {
    val cc = a
    fun dd(r: T) {
        println(r)
    }
}


//泛型函数

fun <T> printlnn(value: T) {
    when (value) {
        is Int -> println("传过来的是整形数字$value")
        is String -> println("穿过来的是字符串${value.reversed()}")
        else -> println("啥也不是")
    }
}

//泛型约束

open class aaa
interface bbb


fun <T : aaa> haha(value: T) {

}

class aaaa : aaa(), bbb

//多个条件的泛型约束，使用where语句，并且只能有一个条件是类，其余都可以是接口
//where语句，多个条件同时满足，才能传这个类型，相当于&&
fun <T> jjj(value: T)
        where T : aaa,
              T : bbb {

}


//枚举类用enum修饰，当一个类的对象固定且有限时使用枚举类，可以达到类型安全的意义
enum class getColor {
    Red(), Blue(), White()
}

//对象表达式，对一个类作了轻微的改变，比如增加了某些功能，但却不需要新建子类，有点装饰器的味道，用object修饰
//就是java中的匿名内部类

open class annimal(var string: String) {
    open fun eat() {
        println("$string 在吃早饭")
    }
}

fun eatDrink(a: annimal) {
    a.eat()
}

//对象声明
//我们使用object来申明一个对象，相当于是拿到了类的实例，并且是单例的，
//相当于，我们可以很便捷的拿到一个对象，绕过了去申明类的过程
var c2c = object : annimal("a") {

}

fun text3() {
    c2c.eat()

}


object pen {
    fun write() {
        println("我在写字")
    }
}

//可以有父类，其实相当于是pencil 继承了父类，并且还得到了pencil类的对象，
//同时做了两个步骤，继承了父类，和实例化了对象
object pencil : annimal("劳资") {


}

class outer {
    var name = "wo"

    object inner {
        fun innerDo() {
//            println(name)  当声明对象在一个类的内部时，并不能访问到外部类的成员
        }

    }
}

var o = outer()
fun text1() {
//    println(o.inner) 外部类不能通过它的实例访问到这个对象
    outer.inner.innerDo()//只能通过类名直接访问
}


//伴生对象，从名字看，我们就可以看出来相当于这个对象是伴随着其他东西依托存在的
//用companion修饰，

class floor {
    companion object inner { //其实就是在类 内部的对象声明加了companion关键字，使得inner成了伴生对象
        fun innerDo() {

        }
    }
}

fun text4() {
    floor.innerDo() //伴生对象的成员可以被外部类直接访问，有点静态属性的味道，可以通过类名可以得到
}

class phone {
    companion object {  //我们可以省略掉伴生对象的名字，因为这个名字其实没多大意义
        fun dosomthing() {
            println("do")
        }
    }
}

fun text5() {
    val phone1 = phone.Companion  //我们可以通过类.companion拿到伴生对象，由此可以看出我们类的伴生对象只能有一个，即companion关键字只能用一次
    phone1.dosomthing()
}




























package com.thinkwithu.www.kotlindemo.weituo

/**
 * Author: sean
 * Date: 2019/5/6 11:32
 */
class Me : Xiwan by Biaodi() {
}package com.thinkwithu.www.kotlindemo.weituo

/**
 * Author: sean
 * Date: 2019/5/6 11:33
 */
class Biaodi : Xiwan {
    override fun washing() {
        println("表弟不耐烦在洗碗")
    }

    var a = 4 + 5
    operator fun plus(a: Int) {

    }

    var cc = "aa"
        set(value) {
            field = "99"
        }


}package com.thinkwithu.www.kotlindemo.weituo

/**
 * Author: sean
 * Date: 2019/5/6 11:33
 */

fun main() {
    var me = Me()
    me.washing()
}package com.thinkwithu.www.kotlindemo.weituo

/**
 * Author: sean
 * Date: 2019/5/6 11:32
 */
class Me : Xiwan by Biaodi() {
}package com.thinkwithu.www.kotlindemo.weituo

/**
 * Author: sean
 * Date: 2019/5/6 11:31
 */
interface Xiwan {
    fun washing()
}package com.thinkwithu.www.kotlindemo.weituo

/**
 * Author: sean
 * Date: 2019/5/6 11:33
 */

fun main() {
    var me = Me()
    me.washing()
}package com.thinkwithu.www.kotlindemo

import org.junit.Test

import org.junit.Assert.*

/**
 * Example local unit test, which will execute on the development machine (host).
 *
 * See [testing documentation](http://d.android.com/tools/testing).
 */
class ExampleUnitTest {
    @Test
    fun addition_isCorrect() {
        assertEquals(4, 2 + 2)
    }
}
package com.thinkwithu.www.kotlindemo.weituo

/**
 * Author: sean
 * Date: 2019/5/6 11:31
 */
interface Xiwan {
    fun washing()
}package com.thinkwithu.www.kotlindemo

import org.junit.Test

import org.junit.Assert.*

/**
 * Example local unit test, which will execute on the development machine (host).
 *
 * See [testing documentation](http://d.android.com/tools/testing).
 */
class ExampleUnitTest {
    @Test
    fun addition_isCorrect() {
        assertEquals(4, 2 + 2)
    }
}
package com.thinkwithu.www.kotlindemo

import androidx.test.InstrumentationRegistry
import androidx.test.runner.AndroidJUnit4

import org.junit.Test
import org.junit.runner.RunWith

import org.junit.Assert.*

/**
 * Instrumented test, which will execute on an Android device.
 *
 * See [testing documentation](http://d.android.com/tools/testing).
 */
@RunWith(AndroidJUnit4::class)
class ExampleInstrumentedTest {
    @Test
    fun useAppContext() {
        // Context of the app under test.
        val appContext = InstrumentationRegistry.getTargetContext()
        assertEquals("com.thinkwithu.www.kotlindemo", appContext.packageName)
    }
}
package com.thinkwithu.www.kotlindemo

import java.lang.Exception
import java.lang.IndexOutOfBoundsException
import java.lang.NumberFormatException

/**
 * Copyright (C), 2015-2019, 北京九州申友教育咨询有限公司
 * Author: sean
 * Date: 2019/4/18 16:14
 * Description: ${DESCRIPTION}
 */
fun main() {
//    basictype()
    var argus = arrayOf(5, 10)
//    bianli(argus)
//    abnormal(argus);
//    expression(argus)
//    parameter(4, 4, a = "1")
//    change("a", "b", "v")
//    string()
//    nullText()
//    range()
//    compare()
//    char('5')
//    array(intArrayOf(5, 8))
    string("hello")
}


/**
 * 基本数据类型
 */
fun basictype() {
    //数字：Double,Float,Long,Int,Short,Byte
    var INta = 1 //可以不用指定类型，使用时会自动判断类型
    var LongA = 5L//长整型，用L标记
    var OXA = 0Xff//十六进制，以0x开头标记
    var ObA = 0b1011//二进制，以0b开头
    //不支持8进制
    var DoubleA = 6.55//默认是double类型
    var FloatA = 6.5f//单精度以f结尾
    var oneMillion = 1_000_000//以下划线分割，易读
}

/**
 *  for 循环
 */
fun bianli(argus: ArrayList<String>) {
    for (value in argus) {
        println(value)
    }
    for ((index, value) in argus.withIndex()) {
        println("$index->$value")
    }
    for (indexvalue in argus.withIndex()) {
        println(indexvalue)
    }

}

/**
 * 异常处理
 */

fun abnormal(argus: Array<String>) {
    try {
        var a = argus[0]
        var b = argus[1]
        var c = a.toInt() + b.toInt()
        print(c)
    } catch (e: NumberFormatException) {
        println("您给的是整数吗")
    } catch (e: IndexOutOfBoundsException) {
        println("您给的是两个整数吗")
    } finally {
        println("谢谢使用")
    }

}

/**
 * 表达式
 */
fun expression(argus: Array<Int>) {
    var a = try {
        argus[0].toInt() / argus[1].toInt()
    } catch (e: Exception) {
        e.printStackTrace()
    } finally {
        println("我是表达式")
    }
    println(a)
}

/**
 *vararg修饰变长参数
 * 具名参数
 * 默认参数
 */
fun parameter(vararg ints: Int, a: String, c: Double = 5.2) {
    for (b in ints) println(b)
    println(a)
    println(c)
}

//函数以fun关键字修饰，参数是以变量：类型形式，返回值是以;类型写在最后 ，；可以省略
fun func(a: Int, b: String): Int {
    return 1
}

//表达式作为函数体，返回类型自动判断
fun sun(a: Int, b: Int) = a + b

public fun sum(a: Int, b: Int) = a + b

//无返回值，unit可以省略
fun printsum(a: Int, b: Int): Unit {
    println(a + b)
}

fun printsum1(a: Int, b: Int) {
    println(a + b)
}

//可变长参数用vararg显示
fun change(vararg v: String) {
    for (i in v)
        println(v)
    println("b")
    println("vvv")
}

//var 修饰可变变量，
var cc: String = "7"

fun text() {
//编译器自动识别类型
    var aa = 4
    aa += 1
}

//字符串模板 以$符号
fun string() {
    var a = "a"
    var b = "this is $a"
    var c = "this is ${text()}"
    println(b)
    println(c)
}


//null 安全机制
fun nullText() {
    var a: String? = null// ?表示可为空
//    var b = a!!.toInt()//！！表示如果为null则抛出异常
    var c = a?.toInt()//?表示如果为null则返回null
    var d = a?.toInt() ?: -1//?:表示 如果为null则返回-1
    println(a)
//    println(b)
    println(c)
    println(d)
}


fun typeText(obj: Any): Int? {
    if (obj is String) {
        return obj.length  //obj自动转换成String
    }
    return null
}


fun typeText1(obj: Any): Int? {
    if (obj !is String) {
        return null
    }
    return obj.length //obj自动转换String
}

fun typeText2(obj: Any): Int? {
    if (obj is String && obj.length > 0) {//obj自动转换String
        return obj.length
    }
    return null
}

//区间
fun range() {
    for (i in 1..5) println(i)
    for (i in 1..10 step 2) println(i)
    for (i in 4 downTo 1 step 1) println(i)
    for (i in 2 until 7) println(i)
}


//kt没有基础数据类型，只有封装的数字类型
//两个=表示，比较值的大小，三个=表示比较地址
fun compare() {
    val a = 100
    val b: Int? = a
    val c: Int? = a
    println(c == b)
    println(c === b)
}

fun type() {
    var a: Int = 5
    var b: Long = a.toLong()
    var c: String = a.toString()
}

//字符：不能和数字类型直接操作,可以显示转换成数字类型
fun char(c: Char): Int? {
    if (c in '0'..'9') {
        return c.toInt()
    }
    return null
}

//数组，用Array实现，此外还有IntArray,DoubleArray,等等
fun array(ary: IntArray) {
    println(ary.size)
    println(ary[0])
    ary[0] = 100
    println(ary[0])
}

//字符串可以被遍历，用三个"""可以支持换行操作，用trimmargin去掉字符串前面多余的空格，默认是以竖线分割
fun string(a: String) {
    for (s in a) {
        println(s)
    }
    var s1 = """
多行字符串
        支持
多行字符串用三个双引号
    """
    var s2 = """
        5多行字符串
        5支持
        5多行字符串用三个双引号
    """.trimMargin("5")
    println(s1)
    println(s2)
}















































































package com.thinkwithu.www.kotlindemo

/**
 * Copyright (C), 2015-2019, 北京九州申友教育咨询有限公司
 * Author: sean
 * Date: 2019/4/23 17:13
 * Description: ${DESCRIPTION}
 */
fun main() {

    /* var f = FourClass(88)
     f.cc()
     var fi = Five("", 1, "")*/
    /* var a = eight.nine(10).foo()
     println(a)*/
//    var c = C()
//    c.foo()

//    val user = User();
//    user.extension()

    /* val intarray = intArrayOf(4, 9, 6)
     intarray.extecsion()
     for (i in intarray) {
         println(i)
     }*/
//    entity(v())
//    val yn = yun();
//    yn.foo()

//    var a: String? = null
//    println(a.toString())

//    myclass.foo()
//    moon().sunDo(sun(
//    bb().bbDo(aa())
//    pp().dp(tt1())
//    pp1().dp(tt())
    val jack = mydata("jack", 18)
    val oldjack = jack.copy(age = 45)//copy方法对
    println(jack)
    println(oldjack)

}

//类用class修饰，
class FirstClass {
    public var change: Int = 5 //var申明可变变量
    val a: String = "4" //val申明常量，相当于final


    //成员函数
    fun foo() {
        println("foo")
    }


}

class SecondClass constructor(a: String) {
    //类的主构造器，用constructor修饰，如果没有用可见修饰符修饰，那么constructor可以省略
    var firstClass = FirstClass()//我们可以像使用普通方法那样对类进行实例化，kt中没有new关键字
    var b: Int = 4

    //写了主构造器，能写其他构造器就用this代理主构造器
    /*  constructor(username: String, age: Int){
      }
      constructor(b: Int) {
          this.b = b
      }*/


    fun foo() {
        firstClass.change//通过类名.来获取属性及方法
        firstClass.foo()
    }
}

class ThreeClass() {
    var a = 5
        get() {
            return field + 2008//field只能在get和set方法中使用，用来代替变量的value
        }
        set(value) {
            field = value
        }
    var b = 9
        get
        set

    lateinit var c: String//lateinit用来延迟初始化， 不然在声明变量的时候都必须初始化,只能用于变量var
}

class FourClass(var a: Int) { //主构造器里面申明的变量可以在类范围使用

    init { //类的初始化方法，值的初始化放在init方法里面
        println("init  a  的值是$a")
    }

    fun cc() {
        a = 9
        println("cc  a  的值 是$a")
    }
}


class Five(a: Int, c: String) { //主构造函数如果有参数，那么次构造函数也必需接收这些参数，并为主构造函数代理，使用this关键字
    constructor(b: String, a: Int, c: String) : this(a, c) {

    }
}

open class animal(a: Int) { //open修饰的类才能被继承，默认是被final修饰
    open fun foo() { //open修饰的方法才能被重写，默认是final修饰

    }
}

class person : animal(5) {
    //继承用:格式,如果父类有传参构造方法，那么子类必须实现它
    override fun foo() {

    }
}


abstract class six(a: Int) { //abstract修饰抽象类 抽象类不需要用open修饰，也可以被继承
    abstract fun foo() //abstract修饰抽象方法，也可以不用open修饰
}

class seven : six(8) {
    override fun foo() {
        TODO("not implemented") //To change body of created functions use File | Settings | File Templates.
    }
}

class eight() {
    class nine(a: Int) { //调用嵌套类使用：外部类.嵌套类.属性（方法）
        fun foo() = 8
    }
}


class head {
    var a = 100
    fun b() = 99
    inner class foot() { //内部类用inner 修饰，内部类持有外部类的引用，所以能直接访问外部类的属性和方法
        var c = a
        fun d() {
            var e = b()
        }
    }
}

class book : Any() //所有的类都默认继承自any类。


open class Person(name: String)

class student(name: String, height: Int) : Person(name) //子类有主构造函数，则基类必须在主构造函数中立即初始化

class teacher : Person {  //子类没有主构造函数，则必须在每一个次构造函数中,用super关键字实例化父类
    constructor(name: String) : super(name) {

    }

    constructor(height: Int, name: String) : super(name) {

    }

}


open class A {
    open val a = 99 //属性被open修饰，可以被重写
    open fun foo() {
        println("A")
    }
}

interface B {
    fun foo() { //接口的方法默认是open
        println("B")
    }
}

class C : A(), B { //子类c继承A和实现B,如果A和B有相同的方法，则子类C必须重写这个方法，我们可以用super<>关键字调用哪个父类的方法
    override fun foo() {  //kotlin和java一样，也不能多继承
        super<A>.foo()
        super<B>.foo()
    }

    override var a = 100  //val修饰的常量可以被重写成var变量，反之则不行
    fun d() {
        a = 999
    }

}

interface t {
    var a: Int //变量不允许被初始化，只能是抽象的
    fun b()
    fun c() { //方法可以有默认实现
        println("c")
    }

}

interface tf {
    fun b() {
        println("tf b")
    }

    fun c() {
        println("tf  c")
    }

}


class imp : t {  //实现接口，用: ，
    override var a: Int = 5//子类必须重写接口的属性值

    override fun b() { //没有默认实现的方法，必须重写
        TODO("not implemented") //To change body of created functions use File | Settings | File Templates.
    }
}

class imp1 : t, tf {
    override var a: Int = 88

    override fun b() {//重写接口没被实现的方法，必须重写
        super<tf>.b()
    }

    override fun c() {//重写 两个接口都有的方法 必须重写
        super<t>.c()
        super<tf>.c()
    }

}


class User//空类

//作用域在顶级包下
fun User.extension() {//扩展函数  以fun修饰，以类名.方法名进行扩展，对原类不产生任何影响
    println("我是扩展函数")
}

fun IntArray.extecsion() { //有了扩展函数之后 就可以很方便的对系统函数进行扩展了
    var a = this[0]
    this[0] = this[2]
    this[2] = a
}

//扩展函数是静态解析的，并不是接收者类型的虚拟成员,到底执行哪个扩展函数，是由调用者直接决定的，而不是由动态调用者决定，
//换句话说如果是父类调用扩展函数，而子类也有该扩展函数，当传入的对象是子类时，也是有父类执行扩展函数
open class w

class v : w()

fun w.foo() {
    println("我是w的扩展函数")
}

fun v.foo() {
    println("我是v的扩展函数")
}

fun entity(w1: w) {
    w1.foo()
}


//当扩展函数和成员函数相同时，会优先调用成员函数
class yun {
    fun foo() {
        println("成员")
    }
}

fun yun.foo() {
    println("扩展")
}

//null也可以有扩展函数
fun Any?.haha() {

}

//扩展属性 ,只能支持val，由于没有filed，所以不能被初始化，只能显示初始化
//只能定义在类和kt文件中，不允许定义在方法中
val User.to: Int
    get() {
        return 4
    }

fun User.text() {
    val a = 8
    println(this.to)
}


//伴生对象
class myclass {
    companion object {

    }
}

fun myclass.Companion.foo() {
    println("我是伴生对象的扩展方法啊")
}


class sun {
    fun speak() {
        println("我是太阳，在说话")
    }
}


class moon {

    fun hahaa() {
        println("我是月亮的哈哈")
    }

    //当一个类的扩展函数是另一个类的成员函数时，这个函数内既可以调用扩展接受者的成员函数，也可以调用分发接收者的成员函数
    //这个方法的作用域只能在该类中
    fun sun.sing() {
        speak()
        hahaa()
        println("我是太阳，在唱歌")
    }

    fun sunDo(s: sun) {
        s.sing()
    }


}


class aa {
    fun foo() {
        println("aa foo")
    }
}

class bb {
    fun foo() {
        println("bb foo")
    }

    fun aa.other() {
        foo() //当扩展接受者和分发接收者都有同样的方法时，会优先调用扩展接收者
        this@bb.foo()//可以使用this关键字@类名调用分发接收者的方法
        println("other")
    }

    fun bbDo(a: aa) {
        a.other()
    }

}


open class tt

class tt1 : tt()


open class pp {

    open fun tt.dt() {
        println("pp里面的tt")
    }

    open fun tt1.dt() {
        println("pp里面的tt1")
    }

    fun dp(t: tt) { //针对扩展接收者，仍然是静态的，不会因为动态类型而改变
        t.dt()
    }
}


//针对扩展接收者和分发接收者而言，扩展接收者重写之后也是属于静态解析，而分发接收者 则不同
class pp1 : pp() {
    override fun tt.dt() {  //方法被重写了，用pp1去调用也会生效，
        println("pp1 里面的tt")
    }

    override fun tt1.dt() {
        println("pp1 里面的tt1")
    }

}

//数据类 用data 关键字修饰，主构造方法必须有参数，可以用copy方法复制数据对象的数据
data class mydata(val name: String, val age: Int)

























































































package com.thinkwithu.www.kotlindemo

/**
 * Copyright (C), 2015-2019, 北京九州申友教育咨询有限公司
 * Author: sean
 * Date: 2019/4/23 12:02
 * Description: ${DESCRIPTION}
 */

// main方法是kt的进入方法，好比java的main方法
fun main() {
//    conditionif(5, 9);
//    conditionwhen("李四", 5)
//    conditionfor()
    conditionwhile()
}

fun conditionif(a: Int, b: Int) {
    //传统用法
    var max: Int = b
    if (a > b) max = a
    //用if  else
    if (a > b) {
        max = a
    } else {
        max = b
    }
    //if作为表达式，可以进行赋值，取代java的三目运算符
    max = if (a > b) {
        a
    } else {
        b
    }
    max = if (a > b) a else b
    println("max的值是$max")

    if (a in 5..9) {
        println("$a 在区间")
    }
}

//when 相当于增强版的java switch case语句 支持任意类型，不用写break
fun conditionwhen(a: String, b: Int) {
    when (a) {
        "张三" -> println("我是张三")
        "李四" -> println("我是李四")
        else -> println("我是王五")
    }

    when (b) {
        4, 5 -> println("b的值是4或者5")//条件可以写在一起，
        in 1..10 -> println("在区间1到10之间")//支持in  ,!in写法
        !in 50..100 -> println("不在50到100之间")
        is Int -> println("是整型")//支持is  !is写法
    }

    when {
        b == 1 -> println("b的值是1") //不传参，取代if  else 的写法，不传参数
        b == 2 -> println("b的值是2")
        else -> println("b的值不知道是多少")
    }

    var d = when (b) { //when语句作为表达式，可以进行赋值
        1 -> 11
        2 -> 22
        else -> 8
    }
    println(d)
}

fun conditionfor() {
    var a = arrayOf(4, 5, 6)
    for (b in a) {
        println(b)
    }
    for (c in a.withIndex()) {
        println(c)
    }
    for (d in a) {
        if (d == 4) continue //结束本次循环，继续下一次
        if (d == 5) break //跳出循环
    }

    oop@ for (e in a) {  //以名字加上@符号 给表达式取名
        for (j in a) {
            break@oop //跳出最外层循环
        }
    }


}

fun conditionwhile() {
    var a = 0
    while (a > 0) { //满足条件 就会继续执行
        println(--a)
    }
    println("--------------")
    do {
        println(--a)  //先执行一次，在进去while判断
    } while (a > 0)


}









package com.thinkwithu.www.kotlindemo.dsl

/**
 * Author: sean
 * Date: 2019/5/14 11:15
 */

/**
 * <html>
 *     <body>
 *    </body>
</html>
 */

fun main() {
    //高阶函数
    val html = html {
        head {

        }
        body {
            div {

            }
        }

    }
    println(html)
}

fun Body.div(block: () -> Unit) {
    val d=Div()
    setTag(d)
}


fun html(block: Html.() -> Unit): Html {
    val h = Html()
    block(h)
    return h
}

fun Html.body(block:Body.() -> Unit) {
    val b = Body()
    block(b)
    setTag(b)
}

fun Html.head(block: () -> Unit) {
    val h = Head()
    setTag(h)
}


open class Tag(val name: String) {
    val list = ArrayList<Tag>()

    fun setTag(tag: Tag) {
        list.add(tag)
    }

    override fun toString(): String {
        val stringBuilder = StringBuilder()
        stringBuilder.append("<$name>")
        list.forEach { stringBuilder.append(it.toString()) }
        stringBuilder.append("</$name>")
        return stringBuilder.toString()
    }
}

class Html : Tag("html")
class Body : Tag("body")
class Head : Tag("head")
class Div : Tag("div")
package com.thinkwithu.www.kotlindemo.fanxing

/**
 * Author: sean
 * Date: 2019/5/8 10:17
 */

fun main(args: Array<String>) {
    aaa.cc()
}

abstract class annimal

class Dog : annimal()

class cat : annimal()

open class Box<T>(thing: T)

class AnnimalBox(annimal: annimal) : Box<annimal>(annimal)


class aaa() {
    companion object {
        var a = ""
        fun cc() {

        }
    }
}
package com.thinkwithu.www.kotlindemo.fanxing.函数回调

/**
 * Author: sean
 * Date: 2019/5/13 14:51
 */


fun main() {
    val us = usa()
    us.chinesehome({
        it.copy()
    })
}

data class xinpian(var name: String)

class aaa(aaa5: Int) {
}

class aaa1(var int5: Int) {
    fun cc(){
        int5=9
    }
}

class chinese() {
    val us = usa()

}

class usa() {
    fun chinesehome(f: (xinpian) -> Unit) {
        val xinpian = xinpian("小霸王")
        f.invoke(xinpian)
    }
}


package com.thinkwithu.www.kotlindemo.fanxing

/**
 * Author: sean
 * Date: 2019/5/8 16:25
 */


fun main() {
//    danli.instance.name
//    danli.instance.age
//    println(text(C()))
    //获取函数的引用，用::函数名可以获取函数的引用
    /*  println(jisuan(4, 7, ::add))
      //lambda 表达式
      println(jisuan(77, 99, { m, n ->
          println()
          m - n
      }))
      //lambda表达式  去括号  括号前移
      println(jisuan(4, 9) { m, n ->
          m + n
      })*/
  /*  lamba(4)
    //使用lambda的时候，如果参数只有一个，那么可以省略参数不写，默认参数就是it
    jisuan(4, {
        it + 10
    })*/
    var list= listOf<String>("a","b","c")
   /* list.filter {  }*/

}

class danli() {
    var name = "asd"
    val age by lazy {
        5
    }
    //lateinit  不能修饰基本类型
    lateinit var height: String

    companion object {
        val instance by lazy {
            danli()
        }
    }

}


open class A
class B : A()
class C : A()
class D : A()

fun text(a: A): Boolean {
    return when (a) {
        is B -> true
        is D -> true
        else -> false
    }
}


fun add(a: Int, b: Int) = a + b
fun jian(a: Int, b: Int) = a - b

//高阶函数
fun jisuan(a: Int, b: Int, block: (Int, Int) -> Int): Int {
    return block.invoke(a, b)
}

//高阶函数
fun jisuan(a: Int, block: (Int) -> Int): Int {
    return block.invoke(a)
}

val lamba = { a: Int ->
    a
}








package com.thinkwithu.www.kotlindemo.fanxing.四大函数


/**
 * Author: sean
 * Date: 2019/5/13 11:33
 */

fun main(args: Array<String>) {
    val list = arrayListOf<String>("aaa")
    /**
     * 1.任何类型的扩展方法
     * 2.参数是有接收者的函数
     * 返回值是自己
     */
    list.apply {
        add("222")
        add("222")
    }

    /**
     * 1.参数是有一个参数的函数，参数函数的返回值是泛型R
     * 函数的返回值是参数函数的返回值
     */
    list.let {
        it.add("44")
        "ssss"
    }.length

    /**
     * 相当于是apply和let方法的合成题
     * 有两个参数，第一个参数是任意类型，第二个参数是有接收类型的函数，
     * 函数的返回值是第二个函数参数的返回值
     */
    with(8, {
        toString()
        "aaa"
    }).length

    /*
    1.参数是有接收类型的函数，接收类型是调用类型
    函数的返回值是函数参数的返回值
     */
    list.run {
        add("aaa")
        "rrrr"
    }.toString()


}

package com.thinkwithu.www.kotlindemo.heima

import java.lang.Exception
import java.math.BigInteger

/**
 * Copyright (C), 2015-2019, 北京九州申友教育咨询有限公司
 * Author: sean
 * Date: 2019/5/5 10:54
 * Description: ${DESCRIPTION}
 */

//程序的主方法
fun main(argus: Array<String>) {
//    println(sayHello("xiaozhang"))
//    println(checkAge(19))
//    saveLog(1)
//    println(darary("滁洲岛"))
//    qujian()
//    add(3, 2)
//    hanshu()
//    zhouchang(a = 6.3f)
//    jiaohu()
    println(jiecheng(BigInteger("100000")))
}

fun basic1() {
    var a = 5  //智能推断类型  var  可变的数据
    var b: Byte = 9 //显示指定类型
    var c: Int //指定类型，可以被重新赋值
    c = 99
    val number = "No.123598" //val 是常量，不能被修改，只读数据，确定了就不能被修改
//    number = "sdfdf"

    var d: Boolean
    d = 5 > 4

}


fun sayHello(name: String): String {
    return name
}

fun checkAge(age: Int): Boolean {
    return age > 18
}

fun saveLog(logLeavel: Int) {
    println(logLeavel)
}


//字符串模板    用$符号
fun darary(place: String): String {
    var comtent = """
        今天我去了${place}这里游玩，真好玩
    """.trimIndent()
    return comtent
}


fun qujian() {
    var a = 1..100000
    var result: Int = 0
    for (c in a) {
        result = result + c
    }
    println(result)
}

fun add(a: Int, b: Int) = a + b

fun hanshu() {
    var a = { x: Int, y: Int -> x + y }
    var b: (Int, Int) -> Int = { x, y -> x + y }
    var resule = a(3, 6)
    println(resule)
}


fun zhouchang(pi: Float = 3.14f, a: Float): Float = a * pi


fun jiaohu() {
    while (true) {
        try {
            println("********************************")
            println("请输入第一个数字")
            var a = readLine()!!.toInt()
            println("请输入第二个数字")
            var b = readLine()!!.toInt()
            println("$a + $b =${a + b}")
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }
}



// tailrec  尾递归 优化   不管多少次都要执行
tailrec fun  jiecheng(a: BigInteger): BigInteger {
    println(100000 - a.toInt())
    if (a == BigInteger.ONE) {
        return BigInteger.ONE
    } else {
        return jiecheng(a - BigInteger.ONE)
    }
}





















package com.thinkwithu.www.kotlindemo.heima26

/**
 * Author: sean
 * Date: 2019/5/5 17:36
 */

fun main(args: Array<String>) {
//    han_shu_shi()
    //::函数名，用于声明函数对象
    var add = ::add
    //有两种方式，函数对象的调用，
    println(add(1, 2))
    //这种方式更加安全
    println(add?.invoke(1, 2))


}

fun han_shu_shi() {
    var stringlist = listOf<String>("a", "b", "c")
    //d第一种写法
    /* for (i in stringlist) {
         println(i)
     }
     //第二种写法
     var print = fun(name: String) {
         println(name)
     }
     stringlist.forEach(
         print
     )
     //第三种写法,把参数抽了出来 it就是参数，我们可以直接写函数体
     stringlist.forEach {
         println(it)
     }*/
    println(stringlist.findLast {
        it.equals("a") && it.equals("1")
    })
}

fun add(a: Int,b:Int): Int {
    return a
}

//可变参数 vararg
fun add1(vararg a: Int): Int {
    var result = 0
    a.forEach {
        result += it
    }
    return result
}



package com.thinkwithu.www.kotlindemo

import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import android.widget.Button

class MainActivity : AppCompatActivity() {


    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
    }




}
package com.thinkwithu.www.kotlindemo

/**
 * Copyright (C), 2015-2019, 北京九州申友教育咨询有限公司
 * Author: sean
 * Date: 2019/4/25 17:23
 * Description: ${DESCRIPTION}
 */

fun main() {
    //编译器可以自动识别类型，所以不需要显示传入类型
//    var t1 = generic(8)
//    var t2 = generic<String>("44")
//    t1.dd(78)
//    println(t1.cc)
//    println(t2.cc)
//    printlnn("haha")
//    printlnn(995)
//    printlnn(true)
//    jjj(aaaa())

//    var color = getColor.Red
//    println(getColor.values())
//    println(getColor.valueOf("Blue"))
//    println(color.name)
//    println(color.ordinal)
    /* eatDrink(object : annimal("长颈鹿") {
         override fun eat() {
             super.eat()
             println("$this 在喝水")
         }
     })
     //通过对象表达式，我们可以直接拿到类的对象
     var aa = object : annimal("") {

     }
     var aa1 = object {

     }*/
    val pen1 = pen
    val pen2 = pen
    println(pen1 === pen2)


}

//泛型，即参数化类型，把类型参数化，就和实参一样，一开始我们不知道要传什么类型的参数，所以就用一个参数来代替这个类型，
//当我们准备传入参数的时候，在把类型带上去，是为了避免之后的代码出现问题，这样的话 我们需要string类型，就必须传string，传int就会报错，能从编译期解决类型转换报错的问题

class generic<T>(a: T) {
    val cc = a
    fun dd(r: T) {
        println(r)
    }
}


//泛型函数

fun <T> printlnn(value: T) {
    when (value) {
        is Int -> println("传过来的是整形数字$value")
        is String -> println("穿过来的是字符串${value.reversed()}")
        else -> println("啥也不是")
    }
}

//泛型约束

open class aaa
interface bbb


fun <T : aaa> haha(value: T) {

}

class aaaa : aaa(), bbb

//多个条件的泛型约束，使用where语句，并且只能有一个条件是类，其余都可以是接口
//where语句，多个条件同时满足，才能传这个类型，相当于&&
fun <T> jjj(value: T)
        where T : aaa,
              T : bbb {

}


//枚举类用enum修饰，当一个类的对象固定且有限时使用枚举类，可以达到类型安全的意义
enum class getColor {
    Red(), Blue(), White()
}

//对象表达式，对一个类作了轻微的改变，比如增加了某些功能，但却不需要新建子类，有点装饰器的味道，用object修饰
//就是java中的匿名内部类

open class annimal(var string: String) {
    open fun eat() {
        println("$string 在吃早饭")
    }
}

fun eatDrink(a: annimal) {
    a.eat()
}

//对象声明
//我们使用object来申明一个对象，相当于是拿到了类的实例，并且是单例的，
//相当于，我们可以很便捷的拿到一个对象，绕过了去申明类的过程
var c2c = object : annimal("a") {

}

fun text3() {
    c2c.eat()

}


object pen {
    fun write() {
        println("我在写字")
    }
}

//可以有父类，其实相当于是pencil 继承了父类，并且还得到了pencil类的对象，
//同时做了两个步骤，继承了父类，和实例化了对象
object pencil : annimal("劳资") {


}

class outer {
    var name = "wo"

    object inner {
        fun innerDo() {
//            println(name)  当声明对象在一个类的内部时，并不能访问到外部类的成员
        }

    }
}

var o = outer()
fun text1() {
//    println(o.inner) 外部类不能通过它的实例访问到这个对象
    outer.inner.innerDo()//只能通过类名直接访问
}


//伴生对象，从名字看，我们就可以看出来相当于这个对象是伴随着其他东西依托存在的
//用companion修饰，

class floor {
    companion object inner { //其实就是在类 内部的对象声明加了companion关键字，使得inner成了伴生对象
        fun innerDo() {

        }
    }
}

fun text4() {
    floor.innerDo() //伴生对象的成员可以被外部类直接访问，有点静态属性的味道，可以通过类名可以得到
}

class phone {
    companion object {  //我们可以省略掉伴生对象的名字，因为这个名字其实没多大意义
        fun dosomthing() {
            println("do")
        }
    }
}

fun text5() {
    val phone1 = phone.Companion  //我们可以通过类.companion拿到伴生对象，由此可以看出我们类的伴生对象只能有一个，即companion关键字只能用一次
    phone1.dosomthing()
}




























package com.thinkwithu.www.kotlindemo.weituo

/**
 * Author: sean
 * Date: 2019/5/6 11:33
 */
class Biaodi : Xiwan {
    override fun washing() {
        println("表弟不耐烦在洗碗")
    }

    var a = 4 + 5
    operator fun plus(a: Int) {

    }

    var cc = "aa"
        set(value) {
            field = "99"
        }


}package com.thinkwithu.www.kotlindemo.weituo

/**
 * Author: sean
 * Date: 2019/5/6 11:32
 */
class Me : Xiwan by Biaodi() {
}package com.thinkwithu.www.kotlindemo.weituo

/**
 * Author: sean
 * Date: 2019/5/6 11:33
 */

fun main() {
    var me = Me()
    me.washing()
}package com.thinkwithu.www.kotlindemo.weituo

/**
 * Author: sean
 * Date: 2019/5/6 11:31
 */
interface Xiwan {
    fun washing()
}package com.thinkwithu.www.kotlindemo

import org.junit.Test

import org.junit.Assert.*

/**
 * Example local unit test, which will execute on the development machine (host).
 *
 * See [testing documentation](http://d.android.com/tools/testing).
 */
class ExampleUnitTest {
    @Test
    fun addition_isCorrect() {
        assertEquals(4, 2 + 2)
    }
}
package com.thinkwithu.www.kotlindemo

import androidx.test.InstrumentationRegistry
import androidx.test.runner.AndroidJUnit4

import org.junit.Test
import org.junit.runner.RunWith

import org.junit.Assert.*

/**
 * Instrumented test, which will execute on an Android device.
 *
 * See [testing documentation](http://d.android.com/tools/testing).
 */
@RunWith(AndroidJUnit4::class)
class ExampleInstrumentedTest {
    @Test
    fun useAppContext() {
        // Context of the app under test.
        val appContext = InstrumentationRegistry.getTargetContext()
        assertEquals("com.thinkwithu.www.kotlindemo", appContext.packageName)
    }
}
package com.thinkwithu.www.kotlindemo

import java.lang.Exception
import java.lang.IndexOutOfBoundsException
import java.lang.NumberFormatException

/**
 * Copyright (C), 2015-2019, 北京九州申友教育咨询有限公司
 * Author: sean
 * Date: 2019/4/18 16:14
 * Description: ${DESCRIPTION}
 */
fun main() {
//    basictype()
    var argus = arrayOf(5, 10)
//    bianli(argus)
//    abnormal(argus);
//    expression(argus)
//    parameter(4, 4, a = "1")
//    change("a", "b", "v")
//    string()
//    nullText()
//    range()
//    compare()
//    char('5')
//    array(intArrayOf(5, 8))
    string("hello")
}


/**
 * 基本数据类型
 */
fun basictype() {
    //数字：Double,Float,Long,Int,Short,Byte
    var INta = 1 //可以不用指定类型，使用时会自动判断类型
    var LongA = 5L//长整型，用L标记
    var OXA = 0Xff//十六进制，以0x开头标记
    var ObA = 0b1011//二进制，以0b开头
    //不支持8进制
    var DoubleA = 6.55//默认是double类型
    var FloatA = 6.5f//单精度以f结尾
    var oneMillion = 1_000_000//以下划线分割，易读
}

/**
 *  for 循环
 */
fun bianli(argus: ArrayList<String>) {
    for (value in argus) {
        println(value)
    }
    for ((index, value) in argus.withIndex()) {
        println("$index->$value")
    }
    for (indexvalue in argus.withIndex()) {
        println(indexvalue)
    }

}

/**
 * 异常处理
 */

fun abnormal(argus: Array<String>) {
    try {
        var a = argus[0]
        var b = argus[1]
        var c = a.toInt() + b.toInt()
        print(c)
    } catch (e: NumberFormatException) {
        println("您给的是整数吗")
    } catch (e: IndexOutOfBoundsException) {
        println("您给的是两个整数吗")
    } finally {
        println("谢谢使用")
    }

}

/**
 * 表达式
 */
fun expression(argus: Array<Int>) {
    var a = try {
        argus[0].toInt() / argus[1].toInt()
    } catch (e: Exception) {
        e.printStackTrace()
    } finally {
        println("我是表达式")
    }
    println(a)
}

/**
 *vararg修饰变长参数
 * 具名参数
 * 默认参数
 */
fun parameter(vararg ints: Int, a: String, c: Double = 5.2) {
    for (b in ints) println(b)
    println(a)
    println(c)
}

//函数以fun关键字修饰，参数是以变量：类型形式，返回值是以;类型写在最后 ，；可以省略
fun func(a: Int, b: String): Int {
    return 1
}

//表达式作为函数体，返回类型自动判断
fun sun(a: Int, b: Int) = a + b

public fun sum(a: Int, b: Int) = a + b

//无返回值，unit可以省略
fun printsum(a: Int, b: Int): Unit {
    println(a + b)
}

fun printsum1(a: Int, b: Int) {
    println(a + b)
}

//可变长参数用vararg显示
fun change(vararg v: String) {
    for (i in v)
        println(v)
    println("b")
    println("vvv")
}

//var 修饰可变变量，
var cc: String = "7"

fun text() {
//编译器自动识别类型
    var aa = 4
    aa += 1
}

//字符串模板 以$符号
fun string() {
    var a = "a"
    var b = "this is $a"
    var c = "this is ${text()}"
    println(b)
    println(c)
}


//null 安全机制
fun nullText() {
    var a: String? = null// ?表示可为空
//    var b = a!!.toInt()//！！表示如果为null则抛出异常
    var c = a?.toInt()//?表示如果为null则返回null
    var d = a?.toInt() ?: -1//?:表示 如果为null则返回-1
    println(a)
//    println(b)
    println(c)
    println(d)
}


fun typeText(obj: Any): Int? {
    if (obj is String) {
        return obj.length  //obj自动转换成String
    }
    return null
}


fun typeText1(obj: Any): Int? {
    if (obj !is String) {
        return null
    }
    return obj.length //obj自动转换String
}

fun typeText2(obj: Any): Int? {
    if (obj is String && obj.length > 0) {//obj自动转换String
        return obj.length
    }
    return null
}

//区间
fun range() {
    for (i in 1..5) println(i)
    for (i in 1..10 step 2) println(i)
    for (i in 4 downTo 1 step 1) println(i)
    for (i in 2 until 7) println(i)
}


//kt没有基础数据类型，只有封装的数字类型
//两个=表示，比较值的大小，三个=表示比较地址
fun compare() {
    val a = 100
    val b: Int? = a
    val c: Int? = a
    println(c == b)
    println(c === b)
}

fun type() {
    var a: Int = 5
    var b: Long = a.toLong()
    var c: String = a.toString()
}

//字符：不能和数字类型直接操作,可以显示转换成数字类型
fun char(c: Char): Int? {
    if (c in '0'..'9') {
        return c.toInt()
    }
    return null
}

//数组，用Array实现，此外还有IntArray,DoubleArray,等等
fun array(ary: IntArray) {
    println(ary.size)
    println(ary[0])
    ary[0] = 100
    println(ary[0])
}

//字符串可以被遍历，用三个"""可以支持换行操作，用trimmargin去掉字符串前面多余的空格，默认是以竖线分割
fun string(a: String) {
    for (s in a) {
        println(s)
    }
    var s1 = """
多行字符串
        支持
多行字符串用三个双引号
    """
    var s2 = """
        5多行字符串
        5支持
        5多行字符串用三个双引号
    """.trimMargin("5")
    println(s1)
    println(s2)
}















































































package com.thinkwithu.www.kotlindemo

/**
 * Copyright (C), 2015-2019, 北京九州申友教育咨询有限公司
 * Author: sean
 * Date: 2019/4/23 17:13
 * Description: ${DESCRIPTION}
 */
fun main() {

    /* var f = FourClass(88)
     f.cc()
     var fi = Five("", 1, "")*/
    /* var a = eight.nine(10).foo()
     println(a)*/
//    var c = C()
//    c.foo()

//    val user = User();
//    user.extension()

    /* val intarray = intArrayOf(4, 9, 6)
     intarray.extecsion()
     for (i in intarray) {
         println(i)
     }*/
//    entity(v())
//    val yn = yun();
//    yn.foo()

//    var a: String? = null
//    println(a.toString())

//    myclass.foo()
//    moon().sunDo(sun(
//    bb().bbDo(aa())
//    pp().dp(tt1())
//    pp1().dp(tt())
    val jack = mydata("jack", 18)
    val oldjack = jack.copy(age = 45)//copy方法对
    println(jack)
    println(oldjack)

}

//类用class修饰，
class FirstClass {
    public var change: Int = 5 //var申明可变变量
    val a: String = "4" //val申明常量，相当于final


    //成员函数
    fun foo() {
        println("foo")
    }


}

class SecondClass constructor(a: String) {
    //类的主构造器，用constructor修饰，如果没有用可见修饰符修饰，那么constructor可以省略
    var firstClass = FirstClass()//我们可以像使用普通方法那样对类进行实例化，kt中没有new关键字
    var b: Int = 4

    //写了主构造器，能写其他构造器就用this代理主构造器
    /*  constructor(username: String, age: Int){
      }
      constructor(b: Int) {
          this.b = b
      }*/


    fun foo() {
        firstClass.change//通过类名.来获取属性及方法
        firstClass.foo()
    }
}

class ThreeClass() {
    var a = 5
        get() {
            return field + 2008//field只能在get和set方法中使用，用来代替变量的value
        }
        set(value) {
            field = value
        }
    var b = 9
        get
        set

    lateinit var c: String//lateinit用来延迟初始化， 不然在声明变量的时候都必须初始化,只能用于变量var
}

class FourClass(var a: Int) { //主构造器里面申明的变量可以在类范围使用

    init { //类的初始化方法，值的初始化放在init方法里面
        println("init  a  的值是$a")
    }

    fun cc() {
        a = 9
        println("cc  a  的值 是$a")
    }
}


class Five(a: Int, c: String) { //主构造函数如果有参数，那么次构造函数也必需接收这些参数，并为主构造函数代理，使用this关键字
    constructor(b: String, a: Int, c: String) : this(a, c) {

    }
}

open class animal(a: Int) { //open修饰的类才能被继承，默认是被final修饰
    open fun foo() { //open修饰的方法才能被重写，默认是final修饰

    }
}

class person : animal(5) {
    //继承用:格式,如果父类有传参构造方法，那么子类必须实现它
    override fun foo() {

    }
}


abstract class six(a: Int) { //abstract修饰抽象类 抽象类不需要用open修饰，也可以被继承
    abstract fun foo() //abstract修饰抽象方法，也可以不用open修饰
}

class seven : six(8) {
    override fun foo() {
        TODO("not implemented") //To change body of created functions use File | Settings | File Templates.
    }
}

class eight() {
    class nine(a: Int) { //调用嵌套类使用：外部类.嵌套类.属性（方法）
        fun foo() = 8
    }
}


class head {
    var a = 100
    fun b() = 99
    inner class foot() { //内部类用inner 修饰，内部类持有外部类的引用，所以能直接访问外部类的属性和方法
        var c = a
        fun d() {
            var e = b()
        }
    }
}

class book : Any() //所有的类都默认继承自any类。


open class Person(name: String)

class student(name: String, height: Int) : Person(name) //子类有主构造函数，则基类必须在主构造函数中立即初始化

class teacher : Person {  //子类没有主构造函数，则必须在每一个次构造函数中,用super关键字实例化父类
    constructor(name: String) : super(name) {

    }

    constructor(height: Int, name: String) : super(name) {

    }

}


open class A {
    open val a = 99 //属性被open修饰，可以被重写
    open fun foo() {
        println("A")
    }
}

interface B {
    fun foo() { //接口的方法默认是open
        println("B")
    }
}

class C : A(), B { //子类c继承A和实现B,如果A和B有相同的方法，则子类C必须重写这个方法，我们可以用super<>关键字调用哪个父类的方法
    override fun foo() {  //kotlin和java一样，也不能多继承
        super<A>.foo()
        super<B>.foo()
    }

    override var a = 100  //val修饰的常量可以被重写成var变量，反之则不行
    fun d() {
        a = 999
    }

}

interface t {
    var a: Int //变量不允许被初始化，只能是抽象的
    fun b()
    fun c() { //方法可以有默认实现
        println("c")
    }

}

interface tf {
    fun b() {
        println("tf b")
    }

    fun c() {
        println("tf  c")
    }

}


class imp : t {  //实现接口，用: ，
    override var a: Int = 5//子类必须重写接口的属性值

    override fun b() { //没有默认实现的方法，必须重写
        TODO("not implemented") //To change body of created functions use File | Settings | File Templates.
    }
}

class imp1 : t, tf {
    override var a: Int = 88

    override fun b() {//重写接口没被实现的方法，必须重写
        super<tf>.b()
    }

    override fun c() {//重写 两个接口都有的方法 必须重写
        super<t>.c()
        super<tf>.c()
    }

}


class User//空类

//作用域在顶级包下
fun User.extension() {//扩展函数  以fun修饰，以类名.方法名进行扩展，对原类不产生任何影响
    println("我是扩展函数")
}

fun IntArray.extecsion() { //有了扩展函数之后 就可以很方便的对系统函数进行扩展了
    var a = this[0]
    this[0] = this[2]
    this[2] = a
}

//扩展函数是静态解析的，并不是接收者类型的虚拟成员,到底执行哪个扩展函数，是由调用者直接决定的，而不是由动态调用者决定，
//换句话说如果是父类调用扩展函数，而子类也有该扩展函数，当传入的对象是子类时，也是有父类执行扩展函数
open class w

class v : w()

fun w.foo() {
    println("我是w的扩展函数")
}

fun v.foo() {
    println("我是v的扩展函数")
}

fun entity(w1: w) {
    w1.foo()
}


//当扩展函数和成员函数相同时，会优先调用成员函数
class yun {
    fun foo() {
        println("成员")
    }
}

fun yun.foo() {
    println("扩展")
}

//null也可以有扩展函数
fun Any?.haha() {

}

//扩展属性 ,只能支持val，由于没有filed，所以不能被初始化，只能显示初始化
//只能定义在类和kt文件中，不允许定义在方法中
val User.to: Int
    get() {
        return 4
    }

fun User.text() {
    val a = 8
    println(this.to)
}


//伴生对象
class myclass {
    companion object {

    }
}

fun myclass.Companion.foo() {
    println("我是伴生对象的扩展方法啊")
}


class sun {
    fun speak() {
        println("我是太阳，在说话")
    }
}


class moon {

    fun hahaa() {
        println("我是月亮的哈哈")
    }

    //当一个类的扩展函数是另一个类的成员函数时，这个函数内既可以调用扩展接受者的成员函数，也可以调用分发接收者的成员函数
    //这个方法的作用域只能在该类中
    fun sun.sing() {
        speak()
        hahaa()
        println("我是太阳，在唱歌")
    }

    fun sunDo(s: sun) {
        s.sing()
    }


}


class aa {
    fun foo() {
        println("aa foo")
    }
}

class bb {
    fun foo() {
        println("bb foo")
    }

    fun aa.other() {
        foo() //当扩展接受者和分发接收者都有同样的方法时，会优先调用扩展接收者
        this@bb.foo()//可以使用this关键字@类名调用分发接收者的方法
        println("other")
    }

    fun bbDo(a: aa) {
        a.other()
    }

}


open class tt

class tt1 : tt()


open class pp {

    open fun tt.dt() {
        println("pp里面的tt")
    }

    open fun tt1.dt() {
        println("pp里面的tt1")
    }

    fun dp(t: tt) { //针对扩展接收者，仍然是静态的，不会因为动态类型而改变
        t.dt()
    }
}


//针对扩展接收者和分发接收者而言，扩展接收者重写之后也是属于静态解析，而分发接收者 则不同
class pp1 : pp() {
    override fun tt.dt() {  //方法被重写了，用pp1去调用也会生效，
        println("pp1 里面的tt")
    }

    override fun tt1.dt() {
        println("pp1 里面的tt1")
    }

}

//数据类 用data 关键字修饰，主构造方法必须有参数，可以用copy方法复制数据对象的数据
data class mydata(val name: String, val age: Int)

























































































package com.thinkwithu.www.kotlindemo

/**
 * Copyright (C), 2015-2019, 北京九州申友教育咨询有限公司
 * Author: sean
 * Date: 2019/4/23 12:02
 * Description: ${DESCRIPTION}
 */

// main方法是kt的进入方法，好比java的main方法
fun main() {
//    conditionif(5, 9);
//    conditionwhen("李四", 5)
//    conditionfor()
    conditionwhile()
}

fun conditionif(a: Int, b: Int) {
    //传统用法
    var max: Int = b
    if (a > b) max = a
    //用if  else
    if (a > b) {
        max = a
    } else {
        max = b
    }
    //if作为表达式，可以进行赋值，取代java的三目运算符
    max = if (a > b) {
        a
    } else {
        b
    }
    max = if (a > b) a else b
    println("max的值是$max")

    if (a in 5..9) {
        println("$a 在区间")
    }
}

//when 相当于增强版的java switch case语句 支持任意类型，不用写break
fun conditionwhen(a: String, b: Int) {
    when (a) {
        "张三" -> println("我是张三")
        "李四" -> println("我是李四")
        else -> println("我是王五")
    }

    when (b) {
        4, 5 -> println("b的值是4或者5")//条件可以写在一起，
        in 1..10 -> println("在区间1到10之间")//支持in  ,!in写法
        !in 50..100 -> println("不在50到100之间")
        is Int -> println("是整型")//支持is  !is写法
    }

    when {
        b == 1 -> println("b的值是1") //不传参，取代if  else 的写法，不传参数
        b == 2 -> println("b的值是2")
        else -> println("b的值不知道是多少")
    }

    var d = when (b) { //when语句作为表达式，可以进行赋值
        1 -> 11
        2 -> 22
        else -> 8
    }
    println(d)
}

fun conditionfor() {
    var a = arrayOf(4, 5, 6)
    for (b in a) {
        println(b)
    }
    for (c in a.withIndex()) {
        println(c)
    }
    for (d in a) {
        if (d == 4) continue //结束本次循环，继续下一次
        if (d == 5) break //跳出循环
    }

    oop@ for (e in a) {  //以名字加上@符号 给表达式取名
        for (j in a) {
            break@oop //跳出最外层循环
        }
    }


}

fun conditionwhile() {
    var a = 0
    while (a > 0) { //满足条件 就会继续执行
        println(--a)
    }
    println("--------------")
    do {
        println(--a)  //先执行一次，在进去while判断
    } while (a > 0)


}









package com.thinkwithu.www.kotlindemo.dsl

/**
 * Author: sean
 * Date: 2019/5/14 11:15
 */

/**
 * <html>
 *     <body>
 *    </body>
</html>
 */

fun main() {
    //高阶函数
    val html = html {
        head {

        }
        body {
            div {

            }
        }

    }
    println(html)
}

fun Body.div(block: () -> Unit) {
    val d=Div()
    setTag(d)
}


fun html(block: Html.() -> Unit): Html {
    val h = Html()
    block(h)
    return h
}

fun Html.body(block:Body.() -> Unit) {
    val b = Body()
    block(b)
    setTag(b)
}

fun Html.head(block: () -> Unit) {
    val h = Head()
    setTag(h)
}


open class Tag(val name: String) {
    val list = ArrayList<Tag>()

    fun setTag(tag: Tag) {
        list.add(tag)
    }

    override fun toString(): String {
        val stringBuilder = StringBuilder()
        stringBuilder.append("<$name>")
        list.forEach { stringBuilder.append(it.toString()) }
        stringBuilder.append("</$name>")
        return stringBuilder.toString()
    }
}

class Html : Tag("html")
class Body : Tag("body")
class Head : Tag("head")
class Div : Tag("div")
package com.thinkwithu.www.kotlindemo.fanxing

/**
 * Author: sean
 * Date: 2019/5/8 10:17
 */

fun main(args: Array<String>) {
    aaa.cc()
}

abstract class annimal

class Dog : annimal()

class cat : annimal()

open class Box<T>(thing: T)

class AnnimalBox(annimal: annimal) : Box<annimal>(annimal)


class aaa() {
    companion object {
        var a = ""
        fun cc() {

        }
    }
}
package com.thinkwithu.www.kotlindemo.fanxing.函数回调

/**
 * Author: sean
 * Date: 2019/5/13 14:51
 */


fun main() {
    val us = usa()
    us.chinesehome({
        it.copy()
    })
}

data class xinpian(var name: String)

class aaa(aaa5: Int) {
}

class aaa1(var int5: Int) {
    fun cc(){
        int5=9
    }
}

class chinese() {
    val us = usa()

}

class usa() {
    fun chinesehome(f: (xinpian) -> Unit) {
        val xinpian = xinpian("小霸王")
        f.invoke(xinpian)
    }
}


package com.thinkwithu.www.kotlindemo.fanxing

/**
 * Author: sean
 * Date: 2019/5/8 16:25
 */


fun main() {
//    danli.instance.name
//    danli.instance.age
//    println(text(C()))
    //获取函数的引用，用::函数名可以获取函数的引用
    /*  println(jisuan(4, 7, ::add))
      //lambda 表达式
      println(jisuan(77, 99, { m, n ->
          println()
          m - n
      }))
      //lambda表达式  去括号  括号前移
      println(jisuan(4, 9) { m, n ->
          m + n
      })*/
  /*  lamba(4)
    //使用lambda的时候，如果参数只有一个，那么可以省略参数不写，默认参数就是it
    jisuan(4, {
        it + 10
    })*/
    var list= listOf<String>("a","b","c")
   /* list.filter {  }*/

}

class danli() {
    var name = "asd"
    val age by lazy {
        5
    }
    //lateinit  不能修饰基本类型
    lateinit var height: String

    companion object {
        val instance by lazy {
            danli()
        }
    }

}


open class A
class B : A()
class C : A()
class D : A()

fun text(a: A): Boolean {
    return when (a) {
        is B -> true
        is D -> true
        else -> false
    }
}


fun add(a: Int, b: Int) = a + b
fun jian(a: Int, b: Int) = a - b

//高阶函数
fun jisuan(a: Int, b: Int, block: (Int, Int) -> Int): Int {
    return block.invoke(a, b)
}

//高阶函数
fun jisuan(a: Int, block: (Int) -> Int): Int {
    return block.invoke(a)
}

val lamba = { a: Int ->
    a
}








package com.thinkwithu.www.kotlindemo.fanxing.四大函数


/**
 * Author: sean
 * Date: 2019/5/13 11:33
 */

fun main(args: Array<String>) {
    val list = arrayListOf<String>("aaa")
    /**
     * 1.任何类型的扩展方法
     * 2.参数是有接收者的函数
     * 返回值是自己
     */
    list.apply {
        add("222")
        add("222")
    }

    /**
     * 1.参数是有一个参数的函数，参数函数的返回值是泛型R
     * 函数的返回值是参数函数的返回值
     */
    list.let {
        it.add("44")
        "ssss"
    }.length

    /**
     * 相当于是apply和let方法的合成题
     * 有两个参数，第一个参数是任意类型，第二个参数是有接收类型的函数，
     * 函数的返回值是第二个函数参数的返回值
     */
    with(8, {
        toString()
        "aaa"
    }).length

    /*
    1.参数是有接收类型的函数，接收类型是调用类型
    函数的返回值是函数参数的返回值
     */
    list.run {
        add("aaa")
        "rrrr"
    }.toString()


}

package com.thinkwithu.www.kotlindemo.heima

import java.lang.Exception
import java.math.BigInteger

/**
 * Copyright (C), 2015-2019, 北京九州申友教育咨询有限公司
 * Author: sean
 * Date: 2019/5/5 10:54
 * Description: ${DESCRIPTION}
 */

//程序的主方法
fun main(argus: Array<String>) {
//    println(sayHello("xiaozhang"))
//    println(checkAge(19))
//    saveLog(1)
//    println(darary("滁洲岛"))
//    qujian()
//    add(3, 2)
//    hanshu()
//    zhouchang(a = 6.3f)
//    jiaohu()
    println(jiecheng(BigInteger("100000")))
}

fun basic1() {
    var a = 5  //智能推断类型  var  可变的数据
    var b: Byte = 9 //显示指定类型
    var c: Int //指定类型，可以被重新赋值
    c = 99
    val number = "No.123598" //val 是常量，不能被修改，只读数据，确定了就不能被修改
//    number = "sdfdf"

    var d: Boolean
    d = 5 > 4

}


fun sayHello(name: String): String {
    return name
}

fun checkAge(age: Int): Boolean {
    return age > 18
}

fun saveLog(logLeavel: Int) {
    println(logLeavel)
}


//字符串模板    用$符号
fun darary(place: String): String {
    var comtent = """
        今天我去了${place}这里游玩，真好玩
    """.trimIndent()
    return comtent
}


fun qujian() {
    var a = 1..100000
    var result: Int = 0
    for (c in a) {
        result = result + c
    }
    println(result)
}

fun add(a: Int, b: Int) = a + b

fun hanshu() {
    var a = { x: Int, y: Int -> x + y }
    var b: (Int, Int) -> Int = { x, y -> x + y }
    var resule = a(3, 6)
    println(resule)
}


fun zhouchang(pi: Float = 3.14f, a: Float): Float = a * pi


fun jiaohu() {
    while (true) {
        try {
            println("********************************")
            println("请输入第一个数字")
            var a = readLine()!!.toInt()
            println("请输入第二个数字")
            var b = readLine()!!.toInt()
            println("$a + $b =${a + b}")
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }
}



// tailrec  尾递归 优化   不管多少次都要执行
tailrec fun  jiecheng(a: BigInteger): BigInteger {
    println(100000 - a.toInt())
    if (a == BigInteger.ONE) {
        return BigInteger.ONE
    } else {
        return jiecheng(a - BigInteger.ONE)
    }
}





















package com.thinkwithu.www.kotlindemo.heima26

/**
 * Author: sean
 * Date: 2019/5/5 17:36
 */

fun main(args: Array<String>) {
//    han_shu_shi()
    //::函数名，用于声明函数对象
    var add = ::add
    //有两种方式，函数对象的调用，
    println(add(1, 2))
    //这种方式更加安全
    println(add?.invoke(1, 2))


}

fun han_shu_shi() {
    var stringlist = listOf<String>("a", "b", "c")
    //d第一种写法
    /* for (i in stringlist) {
         println(i)
     }
     //第二种写法
     var print = fun(name: String) {
         println(name)
     }
     stringlist.forEach(
         print
     )
     //第三种写法,把参数抽了出来 it就是参数，我们可以直接写函数体
     stringlist.forEach {
         println(it)
     }*/
    println(stringlist.findLast {
        it.equals("a") && it.equals("1")
    })
}

fun add(a: Int,b:Int): Int {
    return a
}

//可变参数 vararg
fun add1(vararg a: Int): Int {
    var result = 0
    a.forEach {
        result += it
    }
    return result
}



package com.thinkwithu.www.kotlindemo

import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import android.widget.Button

class MainActivity : AppCompatActivity() {


    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
    }




}
package com.thinkwithu.www.kotlindemo

/**
 * Copyright (C), 2015-2019, 北京九州申友教育咨询有限公司
 * Author: sean
 * Date: 2019/4/25 17:23
 * Description: ${DESCRIPTION}
 */

fun main() {
    //编译器可以自动识别类型，所以不需要显示传入类型
//    var t1 = generic(8)
//    var t2 = generic<String>("44")
//    t1.dd(78)
//    println(t1.cc)
//    println(t2.cc)
//    printlnn("haha")
//    printlnn(995)
//    printlnn(true)
//    jjj(aaaa())

//    var color = getColor.Red
//    println(getColor.values())
//    println(getColor.valueOf("Blue"))
//    println(color.name)
//    println(color.ordinal)
    /* eatDrink(object : annimal("长颈鹿") {
         override fun eat() {
             super.eat()
             println("$this 在喝水")
         }
     })
     //通过对象表达式，我们可以直接拿到类的对象
     var aa = object : annimal("") {

     }
     var aa1 = object {

     }*/
    val pen1 = pen
    val pen2 = pen
    println(pen1 === pen2)


}

//泛型，即参数化类型，把类型参数化，就和实参一样，一开始我们不知道要传什么类型的参数，所以就用一个参数来代替这个类型，
//当我们准备传入参数的时候，在把类型带上去，是为了避免之后的代码出现问题，这样的话 我们需要string类型，就必须传string，传int就会报错，能从编译期解决类型转换报错的问题

class generic<T>(a: T) {
    val cc = a
    fun dd(r: T) {
        println(r)
    }
}


//泛型函数

fun <T> printlnn(value: T) {
    when (value) {
        is Int -> println("传过来的是整形数字$value")
        is String -> println("穿过来的是字符串${value.reversed()}")
        else -> println("啥也不是")
    }
}

//泛型约束

open class aaa
interface bbb


fun <T : aaa> haha(value: T) {

}

class aaaa : aaa(), bbb

//多个条件的泛型约束，使用where语句，并且只能有一个条件是类，其余都可以是接口
//where语句，多个条件同时满足，才能传这个类型，相当于&&
fun <T> jjj(value: T)
        where T : aaa,
              T : bbb {

}


//枚举类用enum修饰，当一个类的对象固定且有限时使用枚举类，可以达到类型安全的意义
enum class getColor {
    Red(), Blue(), White()
}

//对象表达式，对一个类作了轻微的改变，比如增加了某些功能，但却不需要新建子类，有点装饰器的味道，用object修饰
//就是java中的匿名内部类

open class annimal(var string: String) {
    open fun eat() {
        println("$string 在吃早饭")
    }
}

fun eatDrink(a: annimal) {
    a.eat()
}

//对象声明
//我们使用object来申明一个对象，相当于是拿到了类的实例，并且是单例的，
//相当于，我们可以很便捷的拿到一个对象，绕过了去申明类的过程
var c2c = object : annimal("a") {

}

fun text3() {
    c2c.eat()

}


object pen {
    fun write() {
        println("我在写字")
    }
}

//可以有父类，其实相当于是pencil 继承了父类，并且还得到了pencil类的对象，
//同时做了两个步骤，继承了父类，和实例化了对象
object pencil : annimal("劳资") {


}

class outer {
    var name = "wo"

    object inner {
        fun innerDo() {
//            println(name)  当声明对象在一个类的内部时，并不能访问到外部类的成员
        }

    }
}

var o = outer()
fun text1() {
//    println(o.inner) 外部类不能通过它的实例访问到这个对象
    outer.inner.innerDo()//只能通过类名直接访问
}


//伴生对象，从名字看，我们就可以看出来相当于这个对象是伴随着其他东西依托存在的
//用companion修饰，

class floor {
    companion object inner { //其实就是在类 内部的对象声明加了companion关键字，使得inner成了伴生对象
        fun innerDo() {

        }
    }
}

fun text4() {
    floor.innerDo() //伴生对象的成员可以被外部类直接访问，有点静态属性的味道，可以通过类名可以得到
}

class phone {
    companion object {  //我们可以省略掉伴生对象的名字，因为这个名字其实没多大意义
        fun dosomthing() {
            println("do")
        }
    }
}

fun text5() {
    val phone1 = phone.Companion  //我们可以通过类.companion拿到伴生对象，由此可以看出我们类的伴生对象只能有一个，即companion关键字只能用一次
    phone1.dosomthing()
}




























package com.thinkwithu.www.kotlindemo.weituo

/**
 * Author: sean
 * Date: 2019/5/6 11:33
 */
class Biaodi : Xiwan {
    override fun washing() {
        println("表弟不耐烦在洗碗")
    }

    var a = 4 + 5
    operator fun plus(a: Int) {

    }

    var cc = "aa"
        set(value) {
            field = "99"
        }


}package com.thinkwithu.www.kotlindemo.weituo

/**
 * Author: sean
 * Date: 2019/5/6 11:32
 */
class Me : Xiwan by Biaodi() {
}package com.thinkwithu.www.kotlindemo.weituo

/**
 * Author: sean
 * Date: 2019/5/6 11:33
 */

fun main() {
    var me = Me()
    me.washing()
}package com.thinkwithu.www.kotlindemo.weituo

/**
 * Author: sean
 * Date: 2019/5/6 11:31
 */
interface Xiwan {
    fun washing()
}package com.thinkwithu.www.kotlindemo

import org.junit.Test

import org.junit.Assert.*

/**
 * Example local unit test, which will execute on the development machine (host).
 *
 * See [testing documentation](http://d.android.com/tools/testing).
 */
class ExampleUnitTest {
    @Test
    fun addition_isCorrect() {
        assertEquals(4, 2 + 2)
    }
}
package com.thinkwithu.www.kotlindemo

import androidx.test.InstrumentationRegistry
import androidx.test.runner.AndroidJUnit4

import org.junit.Test
import org.junit.runner.RunWith

import org.junit.Assert.*

/**
 * Instrumented test, which will execute on an Android device.
 *
 * See [testing documentation](http://d.android.com/tools/testing).
 */
@RunWith(AndroidJUnit4::class)
class ExampleInstrumentedTest {
    @Test
    fun useAppContext() {
        // Context of the app under test.
        val appContext = InstrumentationRegistry.getTargetContext()
        assertEquals("com.thinkwithu.www.kotlindemo", appContext.packageName)
    }
}
package com.thinkwithu.www.kotlindemo

import java.lang.Exception
import java.lang.IndexOutOfBoundsException
import java.lang.NumberFormatException

/**
 * Copyright (C), 2015-2019, 北京九州申友教育咨询有限公司
 * Author: sean
 * Date: 2019/4/18 16:14
 * Description: ${DESCRIPTION}
 */
fun main() {
//    basictype()
    var argus = arrayOf(5, 10)
//    bianli(argus)
//    abnormal(argus);
//    expression(argus)
//    parameter(4, 4, a = "1")
//    change("a", "b", "v")
//    string()
//    nullText()
//    range()
//    compare()
//    char('5')
//    array(intArrayOf(5, 8))
    string("hello")
}


/**
 * 基本数据类型
 */
fun basictype() {
    //数字：Double,Float,Long,Int,Short,Byte
    var INta = 1 //可以不用指定类型，使用时会自动判断类型
    var LongA = 5L//长整型，用L标记
    var OXA = 0Xff//十六进制，以0x开头标记
    var ObA = 0b1011//二进制，以0b开头
    //不支持8进制
    var DoubleA = 6.55//默认是double类型
    var FloatA = 6.5f//单精度以f结尾
    var oneMillion = 1_000_000//以下划线分割，易读
}

/**
 *  for 循环
 */
fun bianli(argus: ArrayList<String>) {
    for (value in argus) {
        println(value)
    }
    for ((index, value) in argus.withIndex()) {
        println("$index->$value")
    }
    for (indexvalue in argus.withIndex()) {
        println(indexvalue)
    }

}

/**
 * 异常处理
 */

fun abnormal(argus: Array<String>) {
    try {
        var a = argus[0]
        var b = argus[1]
        var c = a.toInt() + b.toInt()
        print(c)
    } catch (e: NumberFormatException) {
        println("您给的是整数吗")
    } catch (e: IndexOutOfBoundsException) {
        println("您给的是两个整数吗")
    } finally {
        println("谢谢使用")
    }

}

/**
 * 表达式
 */
fun expression(argus: Array<Int>) {
    var a = try {
        argus[0].toInt() / argus[1].toInt()
    } catch (e: Exception) {
        e.printStackTrace()
    } finally {
        println("我是表达式")
    }
    println(a)
}

/**
 *vararg修饰变长参数
 * 具名参数
 * 默认参数
 */
fun parameter(vararg ints: Int, a: String, c: Double = 5.2) {
    for (b in ints) println(b)
    println(a)
    println(c)
}

//函数以fun关键字修饰，参数是以变量：类型形式，返回值是以;类型写在最后 ，；可以省略
fun func(a: Int, b: String): Int {
    return 1
}

//表达式作为函数体，返回类型自动判断
fun sun(a: Int, b: Int) = a + b

public fun sum(a: Int, b: Int) = a + b

//无返回值，unit可以省略
fun printsum(a: Int, b: Int): Unit {
    println(a + b)
}

fun printsum1(a: Int, b: Int) {
    println(a + b)
}

//可变长参数用vararg显示
fun change(vararg v: String) {
    for (i in v)
        println(v)
    println("b")
    println("vvv")
}

//var 修饰可变变量，
var cc: String = "7"

fun text() {
//编译器自动识别类型
    var aa = 4
    aa += 1
}

//字符串模板 以$符号
fun string() {
    var a = "a"
    var b = "this is $a"
    var c = "this is ${text()}"
    println(b)
    println(c)
}


//null 安全机制
fun nullText() {
    var a: String? = null// ?表示可为空
//    var b = a!!.toInt()//！！表示如果为null则抛出异常
    var c = a?.toInt()//?表示如果为null则返回null
    var d = a?.toInt() ?: -1//?:表示 如果为null则返回-1
    println(a)
//    println(b)
    println(c)
    println(d)
}


fun typeText(obj: Any): Int? {
    if (obj is String) {
        return obj.length  //obj自动转换成String
    }
    return null
}


fun typeText1(obj: Any): Int? {
    if (obj !is String) {
        return null
    }
    return obj.length //obj自动转换String
}

fun typeText2(obj: Any): Int? {
    if (obj is String && obj.length > 0) {//obj自动转换String
        return obj.length
    }
    return null
}

//区间
fun range() {
    for (i in 1..5) println(i)
    for (i in 1..10 step 2) println(i)
    for (i in 4 downTo 1 step 1) println(i)
    for (i in 2 until 7) println(i)
}


//kt没有基础数据类型，只有封装的数字类型
//两个=表示，比较值的大小，三个=表示比较地址
fun compare() {
    val a = 100
    val b: Int? = a
    val c: Int? = a
    println(c == b)
    println(c === b)
}

fun type() {
    var a: Int = 5
    var b: Long = a.toLong()
    var c: String = a.toString()
}

//字符：不能和数字类型直接操作,可以显示转换成数字类型
fun char(c: Char): Int? {
    if (c in '0'..'9') {
        return c.toInt()
    }
    return null
}

//数组，用Array实现，此外还有IntArray,DoubleArray,等等
fun array(ary: IntArray) {
    println(ary.size)
    println(ary[0])
    ary[0] = 100
    println(ary[0])
}

//字符串可以被遍历，用三个"""可以支持换行操作，用trimmargin去掉字符串前面多余的空格，默认是以竖线分割
fun string(a: String) {
    for (s in a) {
        println(s)
    }
    var s1 = """
多行字符串
        支持
多行字符串用三个双引号
    """
    var s2 = """
        5多行字符串
        5支持
        5多行字符串用三个双引号
    """.trimMargin("5")
    println(s1)
    println(s2)
}















































































package com.thinkwithu.www.kotlindemo

/**
 * Copyright (C), 2015-2019, 北京九州申友教育咨询有限公司
 * Author: sean
 * Date: 2019/4/23 17:13
 * Description: ${DESCRIPTION}
 */
fun main() {

    /* var f = FourClass(88)
     f.cc()
     var fi = Five("", 1, "")*/
    /* var a = eight.nine(10).foo()
     println(a)*/
//    var c = C()
//    c.foo()

//    val user = User();
//    user.extension()

    /* val intarray = intArrayOf(4, 9, 6)
     intarray.extecsion()
     for (i in intarray) {
         println(i)
     }*/
//    entity(v())
//    val yn = yun();
//    yn.foo()

//    var a: String? = null
//    println(a.toString())

//    myclass.foo()
//    moon().sunDo(sun(
//    bb().bbDo(aa())
//    pp().dp(tt1())
//    pp1().dp(tt())
    val jack = mydata("jack", 18)
    val oldjack = jack.copy(age = 45)//copy方法对
    println(jack)
    println(oldjack)

}

//类用class修饰，
class FirstClass {
    public var change: Int = 5 //var申明可变变量
    val a: String = "4" //val申明常量，相当于final


    //成员函数
    fun foo() {
        println("foo")
    }


}

class SecondClass constructor(a: String) {
    //类的主构造器，用constructor修饰，如果没有用可见修饰符修饰，那么constructor可以省略
    var firstClass = FirstClass()//我们可以像使用普通方法那样对类进行实例化，kt中没有new关键字
    var b: Int = 4

    //写了主构造器，能写其他构造器就用this代理主构造器
    /*  constructor(username: String, age: Int){
      }
      constructor(b: Int) {
          this.b = b
      }*/


    fun foo() {
        firstClass.change//通过类名.来获取属性及方法
        firstClass.foo()
    }
}

class ThreeClass() {
    var a = 5
        get() {
            return field + 2008//field只能在get和set方法中使用，用来代替变量的value
        }
        set(value) {
            field = value
        }
    var b = 9
        get
        set

    lateinit var c: String//lateinit用来延迟初始化， 不然在声明变量的时候都必须初始化,只能用于变量var
}

class FourClass(var a: Int) { //主构造器里面申明的变量可以在类范围使用

    init { //类的初始化方法，值的初始化放在init方法里面
        println("init  a  的值是$a")
    }

    fun cc() {
        a = 9
        println("cc  a  的值 是$a")
    }
}


class Five(a: Int, c: String) { //主构造函数如果有参数，那么次构造函数也必需接收这些参数，并为主构造函数代理，使用this关键字
    constructor(b: String, a: Int, c: String) : this(a, c) {

    }
}

open class animal(a: Int) { //open修饰的类才能被继承，默认是被final修饰
    open fun foo() { //open修饰的方法才能被重写，默认是final修饰

    }
}

class person : animal(5) {
    //继承用:格式,如果父类有传参构造方法，那么子类必须实现它
    override fun foo() {

    }
}


abstract class six(a: Int) { //abstract修饰抽象类 抽象类不需要用open修饰，也可以被继承
    abstract fun foo() //abstract修饰抽象方法，也可以不用open修饰
}

class seven : six(8) {
    override fun foo() {
        TODO("not implemented") //To change body of created functions use File | Settings | File Templates.
    }
}

class eight() {
    class nine(a: Int) { //调用嵌套类使用：外部类.嵌套类.属性（方法）
        fun foo() = 8
    }
}


class head {
    var a = 100
    fun b() = 99
    inner class foot() { //内部类用inner 修饰，内部类持有外部类的引用，所以能直接访问外部类的属性和方法
        var c = a
        fun d() {
            var e = b()
        }
    }
}

class book : Any() //所有的类都默认继承自any类。


open class Person(name: String)

class student(name: String, height: Int) : Person(name) //子类有主构造函数，则基类必须在主构造函数中立即初始化

class teacher : Person {  //子类没有主构造函数，则必须在每一个次构造函数中,用super关键字实例化父类
    constructor(name: String) : super(name) {

    }

    constructor(height: Int, name: String) : super(name) {

    }

}


open class A {
    open val a = 99 //属性被open修饰，可以被重写
    open fun foo() {
        println("A")
    }
}

interface B {
    fun foo() { //接口的方法默认是open
        println("B")
    }
}

class C : A(), B { //子类c继承A和实现B,如果A和B有相同的方法，则子类C必须重写这个方法，我们可以用super<>关键字调用哪个父类的方法
    override fun foo() {  //kotlin和java一样，也不能多继承
        super<A>.foo()
        super<B>.foo()
    }

    override var a = 100  //val修饰的常量可以被重写成var变量，反之则不行
    fun d() {
        a = 999
    }

}

interface t {
    var a: Int //变量不允许被初始化，只能是抽象的
    fun b()
    fun c() { //方法可以有默认实现
        println("c")
    }

}

interface tf {
    fun b() {
        println("tf b")
    }

    fun c() {
        println("tf  c")
    }

}


class imp : t {  //实现接口，用: ，
    override var a: Int = 5//子类必须重写接口的属性值

    override fun b() { //没有默认实现的方法，必须重写
        TODO("not implemented") //To change body of created functions use File | Settings | File Templates.
    }
}

class imp1 : t, tf {
    override var a: Int = 88

    override fun b() {//重写接口没被实现的方法，必须重写
        super<tf>.b()
    }

    override fun c() {//重写 两个接口都有的方法 必须重写
        super<t>.c()
        super<tf>.c()
    }

}


class User//空类

//作用域在顶级包下
fun User.extension() {//扩展函数  以fun修饰，以类名.方法名进行扩展，对原类不产生任何影响
    println("我是扩展函数")
}

fun IntArray.extecsion() { //有了扩展函数之后 就可以很方便的对系统函数进行扩展了
    var a = this[0]
    this[0] = this[2]
    this[2] = a
}

//扩展函数是静态解析的，并不是接收者类型的虚拟成员,到底执行哪个扩展函数，是由调用者直接决定的，而不是由动态调用者决定，
//换句话说如果是父类调用扩展函数，而子类也有该扩展函数，当传入的对象是子类时，也是有父类执行扩展函数
open class w

class v : w()

fun w.foo() {
    println("我是w的扩展函数")
}

fun v.foo() {
    println("我是v的扩展函数")
}

fun entity(w1: w) {
    w1.foo()
}


//当扩展函数和成员函数相同时，会优先调用成员函数
class yun {
    fun foo() {
        println("成员")
    }
}

fun yun.foo() {
    println("扩展")
}

//null也可以有扩展函数
fun Any?.haha() {

}

//扩展属性 ,只能支持val，由于没有filed，所以不能被初始化，只能显示初始化
//只能定义在类和kt文件中，不允许定义在方法中
val User.to: Int
    get() {
        return 4
    }

fun User.text() {
    val a = 8
    println(this.to)
}


//伴生对象
class myclass {
    companion object {

    }
}

fun myclass.Companion.foo() {
    println("我是伴生对象的扩展方法啊")
}


class sun {
    fun speak() {
        println("我是太阳，在说话")
    }
}


class moon {

    fun hahaa() {
        println("我是月亮的哈哈")
    }

    //当一个类的扩展函数是另一个类的成员函数时，这个函数内既可以调用扩展接受者的成员函数，也可以调用分发接收者的成员函数
    //这个方法的作用域只能在该类中
    fun sun.sing() {
        speak()
        hahaa()
        println("我是太阳，在唱歌")
    }

    fun sunDo(s: sun) {
        s.sing()
    }


}


class aa {
    fun foo() {
        println("aa foo")
    }
}

class bb {
    fun foo() {
        println("bb foo")
    }

    fun aa.other() {
        foo() //当扩展接受者和分发接收者都有同样的方法时，会优先调用扩展接收者
        this@bb.foo()//可以使用this关键字@类名调用分发接收者的方法
        println("other")
    }

    fun bbDo(a: aa) {
        a.other()
    }

}


open class tt

class tt1 : tt()


open class pp {

    open fun tt.dt() {
        println("pp里面的tt")
    }

    open fun tt1.dt() {
        println("pp里面的tt1")
    }

    fun dp(t: tt) { //针对扩展接收者，仍然是静态的，不会因为动态类型而改变
        t.dt()
    }
}


//针对扩展接收者和分发接收者而言，扩展接收者重写之后也是属于静态解析，而分发接收者 则不同
class pp1 : pp() {
    override fun tt.dt() {  //方法被重写了，用pp1去调用也会生效，
        println("pp1 里面的tt")
    }

    override fun tt1.dt() {
        println("pp1 里面的tt1")
    }

}

//数据类 用data 关键字修饰，主构造方法必须有参数，可以用copy方法复制数据对象的数据
data class mydata(val name: String, val age: Int)

























































































package com.thinkwithu.www.kotlindemo

/**
 * Copyright (C), 2015-2019, 北京九州申友教育咨询有限公司
 * Author: sean
 * Date: 2019/4/23 12:02
 * Description: ${DESCRIPTION}
 */

// main方法是kt的进入方法，好比java的main方法
fun main() {
//    conditionif(5, 9);
//    conditionwhen("李四", 5)
//    conditionfor()
    conditionwhile()
}

fun conditionif(a: Int, b: Int) {
    //传统用法
    var max: Int = b
    if (a > b) max = a
    //用if  else
    if (a > b) {
        max = a
    } else {
        max = b
    }
    //if作为表达式，可以进行赋值，取代java的三目运算符
    max = if (a > b) {
        a
    } else {
        b
    }
    max = if (a > b) a else b
    println("max的值是$max")

    if (a in 5..9) {
        println("$a 在区间")
    }
}

//when 相当于增强版的java switch case语句 支持任意类型，不用写break
fun conditionwhen(a: String, b: Int) {
    when (a) {
        "张三" -> println("我是张三")
        "李四" -> println("我是李四")
        else -> println("我是王五")
    }

    when (b) {
        4, 5 -> println("b的值是4或者5")//条件可以写在一起，
        in 1..10 -> println("在区间1到10之间")//支持in  ,!in写法
        !in 50..100 -> println("不在50到100之间")
        is Int -> println("是整型")//支持is  !is写法
    }

    when {
        b == 1 -> println("b的值是1") //不传参，取代if  else 的写法，不传参数
        b == 2 -> println("b的值是2")
        else -> println("b的值不知道是多少")
    }

    var d = when (b) { //when语句作为表达式，可以进行赋值
        1 -> 11
        2 -> 22
        else -> 8
    }
    println(d)
}

fun conditionfor() {
    var a = arrayOf(4, 5, 6)
    for (b in a) {
        println(b)
    }
    for (c in a.withIndex()) {
        println(c)
    }
    for (d in a) {
        if (d == 4) continue //结束本次循环，继续下一次
        if (d == 5) break //跳出循环
    }

    oop@ for (e in a) {  //以名字加上@符号 给表达式取名
        for (j in a) {
            break@oop //跳出最外层循环
        }
    }


}

fun conditionwhile() {
    var a = 0
    while (a > 0) { //满足条件 就会继续执行
        println(--a)
    }
    println("--------------")
    do {
        println(--a)  //先执行一次，在进去while判断
    } while (a > 0)


}









package com.thinkwithu.www.kotlindemo.dsl

/**
 * Author: sean
 * Date: 2019/5/14 11:15
 */

/**
 * <html>
 *     <body>
 *    </body>
</html>
 */

fun main() {
    //高阶函数
    val html = html {
        head {

        }
        body {
            div {

            }
        }

    }
    println(html)
}

fun Body.div(block: () -> Unit) {
    val d=Div()
    setTag(d)
}


fun html(block: Html.() -> Unit): Html {
    val h = Html()
    block(h)
    return h
}

fun Html.body(block:Body.() -> Unit) {
    val b = Body()
    block(b)
    setTag(b)
}

fun Html.head(block: () -> Unit) {
    val h = Head()
    setTag(h)
}


open class Tag(val name: String) {
    val list = ArrayList<Tag>()

    fun setTag(tag: Tag) {
        list.add(tag)
    }

    override fun toString(): String {
        val stringBuilder = StringBuilder()
        stringBuilder.append("<$name>")
        list.forEach { stringBuilder.append(it.toString()) }
        stringBuilder.append("</$name>")
        return stringBuilder.toString()
    }
}

class Html : Tag("html")
class Body : Tag("body")
class Head : Tag("head")
class Div : Tag("div")
package com.thinkwithu.www.kotlindemo.fanxing

/**
 * Author: sean
 * Date: 2019/5/8 10:17
 */

fun main(args: Array<String>) {
    aaa.cc()
}

abstract class annimal

class Dog : annimal()

class cat : annimal()

open class Box<T>(thing: T)

class AnnimalBox(annimal: annimal) : Box<annimal>(annimal)


class aaa() {
    companion object {
        var a = ""
        fun cc() {

        }
    }
}
package com.thinkwithu.www.kotlindemo.fanxing.函数回调

/**
 * Author: sean
 * Date: 2019/5/13 14:51
 */


fun main() {
    val us = usa()
    us.chinesehome({
        it.copy()
    })
}

data class xinpian(var name: String)

class aaa(aaa5: Int) {
}

class aaa1(var int5: Int) {
    fun cc(){
        int5=9
    }
}

class chinese() {
    val us = usa()

}

class usa() {
    fun chinesehome(f: (xinpian) -> Unit) {
        val xinpian = xinpian("小霸王")
        f.invoke(xinpian)
    }
}


package com.thinkwithu.www.kotlindemo.fanxing

/**
 * Author: sean
 * Date: 2019/5/8 16:25
 */


fun main() {
//    danli.instance.name
//    danli.instance.age
//    println(text(C()))
    //获取函数的引用，用::函数名可以获取函数的引用
    /*  println(jisuan(4, 7, ::add))
      //lambda 表达式
      println(jisuan(77, 99, { m, n ->
          println()
          m - n
      }))
      //lambda表达式  去括号  括号前移
      println(jisuan(4, 9) { m, n ->
          m + n
      })*/
  /*  lamba(4)
    //使用lambda的时候，如果参数只有一个，那么可以省略参数不写，默认参数就是it
    jisuan(4, {
        it + 10
    })*/
    var list= listOf<String>("a","b","c")
   /* list.filter {  }*/

}

class danli() {
    var name = "asd"
    val age by lazy {
        5
    }
    //lateinit  不能修饰基本类型
    lateinit var height: String

    companion object {
        val instance by lazy {
            danli()
        }
    }

}


open class A
class B : A()
class C : A()
class D : A()

fun text(a: A): Boolean {
    return when (a) {
        is B -> true
        is D -> true
        else -> false
    }
}


fun add(a: Int, b: Int) = a + b
fun jian(a: Int, b: Int) = a - b

//高阶函数
fun jisuan(a: Int, b: Int, block: (Int, Int) -> Int): Int {
    return block.invoke(a, b)
}

//高阶函数
fun jisuan(a: Int, block: (Int) -> Int): Int {
    return block.invoke(a)
}

val lamba = { a: Int ->
    a
}








package com.thinkwithu.www.kotlindemo.fanxing.四大函数


/**
 * Author: sean
 * Date: 2019/5/13 11:33
 */

fun main(args: Array<String>) {
    val list = arrayListOf<String>("aaa")
    /**
     * 1.任何类型的扩展方法
     * 2.参数是有接收者的函数
     * 返回值是自己
     */
    list.apply {
        add("222")
        add("222")
    }

    /**
     * 1.参数是有一个参数的函数，参数函数的返回值是泛型R
     * 函数的返回值是参数函数的返回值
     */
    list.let {
        it.add("44")
        "ssss"
    }.length

    /**
     * 相当于是apply和let方法的合成题
     * 有两个参数，第一个参数是任意类型，第二个参数是有接收类型的函数，
     * 函数的返回值是第二个函数参数的返回值
     */
    with(8, {
        toString()
        "aaa"
    }).length

    /*
    1.参数是有接收类型的函数，接收类型是调用类型
    函数的返回值是函数参数的返回值
     */
    list.run {
        add("aaa")
        "rrrr"
    }.toString()


}

package com.thinkwithu.www.kotlindemo.heima

import java.lang.Exception
import java.math.BigInteger

/**
 * Copyright (C), 2015-2019, 北京九州申友教育咨询有限公司
 * Author: sean
 * Date: 2019/5/5 10:54
 * Description: ${DESCRIPTION}
 */

//程序的主方法
fun main(argus: Array<String>) {
//    println(sayHello("xiaozhang"))
//    println(checkAge(19))
//    saveLog(1)
//    println(darary("滁洲岛"))
//    qujian()
//    add(3, 2)
//    hanshu()
//    zhouchang(a = 6.3f)
//    jiaohu()
    println(jiecheng(BigInteger("100000")))
}

fun basic1() {
    var a = 5  //智能推断类型  var  可变的数据
    var b: Byte = 9 //显示指定类型
    var c: Int //指定类型，可以被重新赋值
    c = 99
    val number = "No.123598" //val 是常量，不能被修改，只读数据，确定了就不能被修改
//    number = "sdfdf"

    var d: Boolean
    d = 5 > 4

}


fun sayHello(name: String): String {
    return name
}

fun checkAge(age: Int): Boolean {
    return age > 18
}

fun saveLog(logLeavel: Int) {
    println(logLeavel)
}


//字符串模板    用$符号
fun darary(place: String): String {
    var comtent = """
        今天我去了${place}这里游玩，真好玩
    """.trimIndent()
    return comtent
}


fun qujian() {
    var a = 1..100000
    var result: Int = 0
    for (c in a) {
        result = result + c
    }
    println(result)
}

fun add(a: Int, b: Int) = a + b

fun hanshu() {
    var a = { x: Int, y: Int -> x + y }
    var b: (Int, Int) -> Int = { x, y -> x + y }
    var resule = a(3, 6)
    println(resule)
}


fun zhouchang(pi: Float = 3.14f, a: Float): Float = a * pi


fun jiaohu() {
    while (true) {
        try {
            println("********************************")
            println("请输入第一个数字")
            var a = readLine()!!.toInt()
            println("请输入第二个数字")
            var b = readLine()!!.toInt()
            println("$a + $b =${a + b}")
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }
}



// tailrec  尾递归 优化   不管多少次都要执行
tailrec fun  jiecheng(a: BigInteger): BigInteger {
    println(100000 - a.toInt())
    if (a == BigInteger.ONE) {
        return BigInteger.ONE
    } else {
        return jiecheng(a - BigInteger.ONE)
    }
}





















package com.thinkwithu.www.kotlindemo.heima26

/**
 * Author: sean
 * Date: 2019/5/5 17:36
 */

fun main(args: Array<String>) {
//    han_shu_shi()
    //::函数名，用于声明函数对象
    var add = ::add
    //有两种方式，函数对象的调用，
    println(add(1, 2))
    //这种方式更加安全
    println(add?.invoke(1, 2))


}

fun han_shu_shi() {
    var stringlist = listOf<String>("a", "b", "c")
    //d第一种写法
    /* for (i in stringlist) {
         println(i)
     }
     //第二种写法
     var print = fun(name: String) {
         println(name)
     }
     stringlist.forEach(
         print
     )
     //第三种写法,把参数抽了出来 it就是参数，我们可以直接写函数体
     stringlist.forEach {
         println(it)
     }*/
    println(stringlist.findLast {
        it.equals("a") && it.equals("1")
    })
}

fun add(a: Int,b:Int): Int {
    return a
}

//可变参数 vararg
fun add1(vararg a: Int): Int {
    var result = 0
    a.forEach {
        result += it
    }
    return result
}



package com.thinkwithu.www.kotlindemo

import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import android.widget.Button

class MainActivity : AppCompatActivity() {


    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
    }




}
package com.thinkwithu.www.kotlindemo

/**
 * Copyright (C), 2015-2019, 北京九州申友教育咨询有限公司
 * Author: sean
 * Date: 2019/4/25 17:23
 * Description: ${DESCRIPTION}
 */

fun main() {
    //编译器可以自动识别类型，所以不需要显示传入类型
//    var t1 = generic(8)
//    var t2 = generic<String>("44")
//    t1.dd(78)
//    println(t1.cc)
//    println(t2.cc)
//    printlnn("haha")
//    printlnn(995)
//    printlnn(true)
//    jjj(aaaa())

//    var color = getColor.Red
//    println(getColor.values())
//    println(getColor.valueOf("Blue"))
//    println(color.name)
//    println(color.ordinal)
    /* eatDrink(object : annimal("长颈鹿") {
         override fun eat() {
             super.eat()
             println("$this 在喝水")
         }
     })
     //通过对象表达式，我们可以直接拿到类的对象
     var aa = object : annimal("") {

     }
     var aa1 = object {

     }*/
    val pen1 = pen
    val pen2 = pen
    println(pen1 === pen2)


}

//泛型，即参数化类型，把类型参数化，就和实参一样，一开始我们不知道要传什么类型的参数，所以就用一个参数来代替这个类型，
//当我们准备传入参数的时候，在把类型带上去，是为了避免之后的代码出现问题，这样的话 我们需要string类型，就必须传string，传int就会报错，能从编译期解决类型转换报错的问题

class generic<T>(a: T) {
    val cc = a
    fun dd(r: T) {
        println(r)
    }
}


//泛型函数

fun <T> printlnn(value: T) {
    when (value) {
        is Int -> println("传过来的是整形数字$value")
        is String -> println("穿过来的是字符串${value.reversed()}")
        else -> println("啥也不是")
    }
}

//泛型约束

open class aaa
interface bbb


fun <T : aaa> haha(value: T) {

}

class aaaa : aaa(), bbb

//多个条件的泛型约束，使用where语句，并且只能有一个条件是类，其余都可以是接口
//where语句，多个条件同时满足，才能传这个类型，相当于&&
fun <T> jjj(value: T)
        where T : aaa,
              T : bbb {

}


//枚举类用enum修饰，当一个类的对象固定且有限时使用枚举类，可以达到类型安全的意义
enum class getColor {
    Red(), Blue(), White()
}

//对象表达式，对一个类作了轻微的改变，比如增加了某些功能，但却不需要新建子类，有点装饰器的味道，用object修饰
//就是java中的匿名内部类

open class annimal(var string: String) {
    open fun eat() {
        println("$string 在吃早饭")
    }
}

fun eatDrink(a: annimal) {
    a.eat()
}

//对象声明
//我们使用object来申明一个对象，相当于是拿到了类的实例，并且是单例的，
//相当于，我们可以很便捷的拿到一个对象，绕过了去申明类的过程
var c2c = object : annimal("a") {

}

fun text3() {
    c2c.eat()

}


object pen {
    fun write() {
        println("我在写字")
    }
}

//可以有父类，其实相当于是pencil 继承了父类，并且还得到了pencil类的对象，
//同时做了两个步骤，继承了父类，和实例化了对象
object pencil : annimal("劳资") {


}

class outer {
    var name = "wo"

    object inner {
        fun innerDo() {
//            println(name)  当声明对象在一个类的内部时，并不能访问到外部类的成员
        }

    }
}

var o = outer()
fun text1() {
//    println(o.inner) 外部类不能通过它的实例访问到这个对象
    outer.inner.innerDo()//只能通过类名直接访问
}


//伴生对象，从名字看，我们就可以看出来相当于这个对象是伴随着其他东西依托存在的
//用companion修饰，

class floor {
    companion object inner { //其实就是在类 内部的对象声明加了companion关键字，使得inner成了伴生对象
        fun innerDo() {

        }
    }
}

fun text4() {
    floor.innerDo() //伴生对象的成员可以被外部类直接访问，有点静态属性的味道，可以通过类名可以得到
}

class phone {
    companion object {  //我们可以省略掉伴生对象的名字，因为这个名字其实没多大意义
        fun dosomthing() {
            println("do")
        }
    }
}

fun text5() {
    val phone1 = phone.Companion  //我们可以通过类.companion拿到伴生对象，由此可以看出我们类的伴生对象只能有一个，即companion关键字只能用一次
    phone1.dosomthing()
}




























package com.thinkwithu.www.kotlindemo.weituo

/**
 * Author: sean
 * Date: 2019/5/6 11:33
 */
class Biaodi : Xiwan {
    override fun washing() {
        println("表弟不耐烦在洗碗")
    }

    var a = 4 + 5
    operator fun plus(a: Int) {

    }

    var cc = "aa"
        set(value) {
            field = "99"
        }


}package com.thinkwithu.www.kotlindemo.weituo

/**
 * Author: sean
 * Date: 2019/5/6 11:32
 */
class Me : Xiwan by Biaodi() {
}package com.thinkwithu.www.kotlindemo.weituo

/**
 * Author: sean
 * Date: 2019/5/6 11:33
 */

fun main() {
    var me = Me()
    me.washing()
}package com.thinkwithu.www.kotlindemo.weituo

/**
 * Author: sean
 * Date: 2019/5/6 11:31
 */
interface Xiwan {
    fun washing()
}package com.thinkwithu.www.kotlindemo

import org.junit.Test

import org.junit.Assert.*

/**
 * Example local unit test, which will execute on the development machine (host).
 *
 * See [testing documentation](http://d.android.com/tools/testing).
 */
class ExampleUnitTest {
    @Test
    fun addition_isCorrect() {
        assertEquals(4, 2 + 2)
    }
}
package com.thinkwithu.www.kotlindemo

import androidx.test.InstrumentationRegistry
import androidx.test.runner.AndroidJUnit4

import org.junit.Test
import org.junit.runner.RunWith

import org.junit.Assert.*

/**
 * Instrumented test, which will execute on an Android device.
 *
 * See [testing documentation](http://d.android.com/tools/testing).
 */
@RunWith(AndroidJUnit4::class)
class ExampleInstrumentedTest {
    @Test
    fun useAppContext() {
        // Context of the app under test.
        val appContext = InstrumentationRegistry.getTargetContext()
        assertEquals("com.thinkwithu.www.kotlindemo", appContext.packageName)
    }
}
package com.thinkwithu.www.kotlindemo

import java.lang.Exception
import java.lang.IndexOutOfBoundsException
import java.lang.NumberFormatException

/**
 * Copyright (C), 2015-2019, 北京九州申友教育咨询有限公司
 * Author: sean
 * Date: 2019/4/18 16:14
 * Description: ${DESCRIPTION}
 */
fun main() {
//    basictype()
    var argus = arrayOf(5, 10)
//    bianli(argus)
//    abnormal(argus);
//    expression(argus)
//    parameter(4, 4, a = "1")
//    change("a", "b", "v")
//    string()
//    nullText()
//    range()
//    compare()
//    char('5')
//    array(intArrayOf(5, 8))
    string("hello")
}


/**
 * 基本数据类型
 */
fun basictype() {
    //数字：Double,Float,Long,Int,Short,Byte
    var INta = 1 //可以不用指定类型，使用时会自动判断类型
    var LongA = 5L//长整型，用L标记
    var OXA = 0Xff//十六进制，以0x开头标记
    var ObA = 0b1011//二进制，以0b开头
    //不支持8进制
    var DoubleA = 6.55//默认是double类型
    var FloatA = 6.5f//单精度以f结尾
    var oneMillion = 1_000_000//以下划线分割，易读
}

/**
 *  for 循环
 */
fun bianli(argus: ArrayList<String>) {
    for (value in argus) {
        println(value)
    }
    for ((index, value) in argus.withIndex()) {
        println("$index->$value")
    }
    for (indexvalue in argus.withIndex()) {
        println(indexvalue)
    }

}

/**
 * 异常处理
 */

fun abnormal(argus: Array<String>) {
    try {
        var a = argus[0]
        var b = argus[1]
        var c = a.toInt() + b.toInt()
        print(c)
    } catch (e: NumberFormatException) {
        println("您给的是整数吗")
    } catch (e: IndexOutOfBoundsException) {
        println("您给的是两个整数吗")
    } finally {
        println("谢谢使用")
    }

}

/**
 * 表达式
 */
fun expression(argus: Array<Int>) {
    var a = try {
        argus[0].toInt() / argus[1].toInt()
    } catch (e: Exception) {
        e.printStackTrace()
    } finally {
        println("我是表达式")
    }
    println(a)
}

/**
 *vararg修饰变长参数
 * 具名参数
 * 默认参数
 */
fun parameter(vararg ints: Int, a: String, c: Double = 5.2) {
    for (b in ints) println(b)
    println(a)
    println(c)
}

//函数以fun关键字修饰，参数是以变量：类型形式，返回值是以;类型写在最后 ，；可以省略
fun func(a: Int, b: String): Int {
    return 1
}

//表达式作为函数体，返回类型自动判断
fun sun(a: Int, b: Int) = a + b

public fun sum(a: Int, b: Int) = a + b

//无返回值，unit可以省略
fun printsum(a: Int, b: Int): Unit {
    println(a + b)
}

fun printsum1(a: Int, b: Int) {
    println(a + b)
}

//可变长参数用vararg显示
fun change(vararg v: String) {
    for (i in v)
        println(v)
    println("b")
    println("vvv")
}

//var 修饰可变变量，
var cc: String = "7"

fun text() {
//编译器自动识别类型
    var aa = 4
    aa += 1
}

//字符串模板 以$符号
fun string() {
    var a = "a"
    var b = "this is $a"
    var c = "this is ${text()}"
    println(b)
    println(c)
}


//null 安全机制
fun nullText() {
    var a: String? = null// ?表示可为空
//    var b = a!!.toInt()//！！表示如果为null则抛出异常
    var c = a?.toInt()//?表示如果为null则返回null
    var d = a?.toInt() ?: -1//?:表示 如果为null则返回-1
    println(a)
//    println(b)
    println(c)
    println(d)
}


fun typeText(obj: Any): Int? {
    if (obj is String) {
        return obj.length  //obj自动转换成String
    }
    return null
}


fun typeText1(obj: Any): Int? {
    if (obj !is String) {
        return null
    }
    return obj.length //obj自动转换String
}

fun typeText2(obj: Any): Int? {
    if (obj is String && obj.length > 0) {//obj自动转换String
        return obj.length
    }
    return null
}

//区间
fun range() {
    for (i in 1..5) println(i)
    for (i in 1..10 step 2) println(i)
    for (i in 4 downTo 1 step 1) println(i)
    for (i in 2 until 7) println(i)
}


//kt没有基础数据类型，只有封装的数字类型
//两个=表示，比较值的大小，三个=表示比较地址
fun compare() {
    val a = 100
    val b: Int? = a
    val c: Int? = a
    println(c == b)
    println(c === b)
}

fun type() {
    var a: Int = 5
    var b: Long = a.toLong()
    var c: String = a.toString()
}

//字符：不能和数字类型直接操作,可以显示转换成数字类型
fun char(c: Char): Int? {
    if (c in '0'..'9') {
        return c.toInt()
    }
    return null
}

//数组，用Array实现，此外还有IntArray,DoubleArray,等等
fun array(ary: IntArray) {
    println(ary.size)
    println(ary[0])
    ary[0] = 100
    println(ary[0])
}

//字符串可以被遍历，用三个"""可以支持换行操作，用trimmargin去掉字符串前面多余的空格，默认是以竖线分割
fun string(a: String) {
    for (s in a) {
        println(s)
    }
    var s1 = """
多行字符串
        支持
多行字符串用三个双引号
    """
    var s2 = """
        5多行字符串
        5支持
        5多行字符串用三个双引号
    """.trimMargin("5")
    println(s1)
    println(s2)
}















































































package com.thinkwithu.www.kotlindemo

/**
 * Copyright (C), 2015-2019, 北京九州申友教育咨询有限公司
 * Author: sean
 * Date: 2019/4/23 17:13
 * Description: ${DESCRIPTION}
 */
fun main() {

    /* var f = FourClass(88)
     f.cc()
     var fi = Five("", 1, "")*/
    /* var a = eight.nine(10).foo()
     println(a)*/
//    var c = C()
//    c.foo()

//    val user = User();
//    user.extension()

    /* val intarray = intArrayOf(4, 9, 6)
     intarray.extecsion()
     for (i in intarray) {
         println(i)
     }*/
//    entity(v())
//    val yn = yun();
//    yn.foo()

//    var a: String? = null
//    println(a.toString())

//    myclass.foo()
//    moon().sunDo(sun(
//    bb().bbDo(aa())
//    pp().dp(tt1())
//    pp1().dp(tt())
    val jack = mydata("jack", 18)
    val oldjack = jack.copy(age = 45)//copy方法对
    println(jack)
    println(oldjack)

}

//类用class修饰，
class FirstClass {
    public var change: Int = 5 //var申明可变变量
    val a: String = "4" //val申明常量，相当于final


    //成员函数
    fun foo() {
        println("foo")
    }


}

class SecondClass constructor(a: String) {
    //类的主构造器，用constructor修饰，如果没有用可见修饰符修饰，那么constructor可以省略
    var firstClass = FirstClass()//我们可以像使用普通方法那样对类进行实例化，kt中没有new关键字
    var b: Int = 4

    //写了主构造器，能写其他构造器就用this代理主构造器
    /*  constructor(username: String, age: Int){
      }
      constructor(b: Int) {
          this.b = b
      }*/


    fun foo() {
        firstClass.change//通过类名.来获取属性及方法
        firstClass.foo()
    }
}

class ThreeClass() {
    var a = 5
        get() {
            return field + 2008//field只能在get和set方法中使用，用来代替变量的value
        }
        set(value) {
            field = value
        }
    var b = 9
        get
        set

    lateinit var c: String//lateinit用来延迟初始化， 不然在声明变量的时候都必须初始化,只能用于变量var
}

class FourClass(var a: Int) { //主构造器里面申明的变量可以在类范围使用

    init { //类的初始化方法，值的初始化放在init方法里面
        println("init  a  的值是$a")
    }

    fun cc() {
        a = 9
        println("cc  a  的值 是$a")
    }
}


class Five(a: Int, c: String) { //主构造函数如果有参数，那么次构造函数也必需接收这些参数，并为主构造函数代理，使用this关键字
    constructor(b: String, a: Int, c: String) : this(a, c) {

    }
}

open class animal(a: Int) { //open修饰的类才能被继承，默认是被final修饰
    open fun foo() { //open修饰的方法才能被重写，默认是final修饰

    }
}

class person : animal(5) {
    //继承用:格式,如果父类有传参构造方法，那么子类必须实现它
    override fun foo() {

    }
}


abstract class six(a: Int) { //abstract修饰抽象类 抽象类不需要用open修饰，也可以被继承
    abstract fun foo() //abstract修饰抽象方法，也可以不用open修饰
}

class seven : six(8) {
    override fun foo() {
        TODO("not implemented") //To change body of created functions use File | Settings | File Templates.
    }
}

class eight() {
    class nine(a: Int) { //调用嵌套类使用：外部类.嵌套类.属性（方法）
        fun foo() = 8
    }
}


class head {
    var a = 100
    fun b() = 99
    inner class foot() { //内部类用inner 修饰，内部类持有外部类的引用，所以能直接访问外部类的属性和方法
        var c = a
        fun d() {
            var e = b()
        }
    }
}

class book : Any() //所有的类都默认继承自any类。


open class Person(name: String)

class student(name: String, height: Int) : Person(name) //子类有主构造函数，则基类必须在主构造函数中立即初始化

class teacher : Person {  //子类没有主构造函数，则必须在每一个次构造函数中,用super关键字实例化父类
    constructor(name: String) : super(name) {

    }

    constructor(height: Int, name: String) : super(name) {

    }

}


open class A {
    open val a = 99 //属性被open修饰，可以被重写
    open fun foo() {
        println("A")
    }
}

interface B {
    fun foo() { //接口的方法默认是open
        println("B")
    }
}

class C : A(), B { //子类c继承A和实现B,如果A和B有相同的方法，则子类C必须重写这个方法，我们可以用super<>关键字调用哪个父类的方法
    override fun foo() {  //kotlin和java一样，也不能多继承
        super<A>.foo()
        super<B>.foo()
    }

    override var a = 100  //val修饰的常量可以被重写成var变量，反之则不行
    fun d() {
        a = 999
    }

}

interface t {
    var a: Int //变量不允许被初始化，只能是抽象的
    fun b()
    fun c() { //方法可以有默认实现
        println("c")
    }

}

interface tf {
    fun b() {
        println("tf b")
    }

    fun c() {
        println("tf  c")
    }

}


class imp : t {  //实现接口，用: ，
    override var a: Int = 5//子类必须重写接口的属性值

    override fun b() { //没有默认实现的方法，必须重写
        TODO("not implemented") //To change body of created functions use File | Settings | File Templates.
    }
}

class imp1 : t, tf {
    override var a: Int = 88

    override fun b() {//重写接口没被实现的方法，必须重写
        super<tf>.b()
    }

    override fun c() {//重写 两个接口都有的方法 必须重写
        super<t>.c()
        super<tf>.c()
    }

}


class User//空类

//作用域在顶级包下
fun User.extension() {//扩展函数  以fun修饰，以类名.方法名进行扩展，对原类不产生任何影响
    println("我是扩展函数")
}

fun IntArray.extecsion() { //有了扩展函数之后 就可以很方便的对系统函数进行扩展了
    var a = this[0]
    this[0] = this[2]
    this[2] = a
}

//扩展函数是静态解析的，并不是接收者类型的虚拟成员,到底执行哪个扩展函数，是由调用者直接决定的，而不是由动态调用者决定，
//换句话说如果是父类调用扩展函数，而子类也有该扩展函数，当传入的对象是子类时，也是有父类执行扩展函数
open class w

class v : w()

fun w.foo() {
    println("我是w的扩展函数")
}

fun v.foo() {
    println("我是v的扩展函数")
}

fun entity(w1: w) {
    w1.foo()
}


//当扩展函数和成员函数相同时，会优先调用成员函数
class yun {
    fun foo() {
        println("成员")
    }
}

fun yun.foo() {
    println("扩展")
}

//null也可以有扩展函数
fun Any?.haha() {

}

//扩展属性 ,只能支持val，由于没有filed，所以不能被初始化，只能显示初始化
//只能定义在类和kt文件中，不允许定义在方法中
val User.to: Int
    get() {
        return 4
    }

fun User.text() {
    val a = 8
    println(this.to)
}


//伴生对象
class myclass {
    companion object {

    }
}

fun myclass.Companion.foo() {
    println("我是伴生对象的扩展方法啊")
}


class sun {
    fun speak() {
        println("我是太阳，在说话")
    }
}


class moon {

    fun hahaa() {
        println("我是月亮的哈哈")
    }

    //当一个类的扩展函数是另一个类的成员函数时，这个函数内既可以调用扩展接受者的成员函数，也可以调用分发接收者的成员函数
    //这个方法的作用域只能在该类中
    fun sun.sing() {
        speak()
        hahaa()
        println("我是太阳，在唱歌")
    }

    fun sunDo(s: sun) {
        s.sing()
    }


}


class aa {
    fun foo() {
        println("aa foo")
    }
}

class bb {
    fun foo() {
        println("bb foo")
    }

    fun aa.other() {
        foo() //当扩展接受者和分发接收者都有同样的方法时，会优先调用扩展接收者
        this@bb.foo()//可以使用this关键字@类名调用分发接收者的方法
        println("other")
    }

    fun bbDo(a: aa) {
        a.other()
    }

}


open class tt

class tt1 : tt()


open class pp {

    open fun tt.dt() {
        println("pp里面的tt")
    }

    open fun tt1.dt() {
        println("pp里面的tt1")
    }

    fun dp(t: tt) { //针对扩展接收者，仍然是静态的，不会因为动态类型而改变
        t.dt()
    }
}


//针对扩展接收者和分发接收者而言，扩展接收者重写之后也是属于静态解析，而分发接收者 则不同
class pp1 : pp() {
    override fun tt.dt() {  //方法被重写了，用pp1去调用也会生效，
        println("pp1 里面的tt")
    }

    override fun tt1.dt() {
        println("pp1 里面的tt1")
    }

}

//数据类 用data 关键字修饰，主构造方法必须有参数，可以用copy方法复制数据对象的数据
data class mydata(val name: String, val age: Int)

























































































package com.thinkwithu.www.kotlindemo

/**
 * Copyright (C), 2015-2019, 北京九州申友教育咨询有限公司
 * Author: sean
 * Date: 2019/4/23 12:02
 * Description: ${DESCRIPTION}
 */

// main方法是kt的进入方法，好比java的main方法
fun main() {
//    conditionif(5, 9);
//    conditionwhen("李四", 5)
//    conditionfor()
    conditionwhile()
}

fun conditionif(a: Int, b: Int) {
    //传统用法
    var max: Int = b
    if (a > b) max = a
    //用if  else
    if (a > b) {
        max = a
    } else {
        max = b
    }
    //if作为表达式，可以进行赋值，取代java的三目运算符
    max = if (a > b) {
        a
    } else {
        b
    }
    max = if (a > b) a else b
    println("max的值是$max")

    if (a in 5..9) {
        println("$a 在区间")
    }
}

//when 相当于增强版的java switch case语句 支持任意类型，不用写break
fun conditionwhen(a: String, b: Int) {
    when (a) {
        "张三" -> println("我是张三")
        "李四" -> println("我是李四")
        else -> println("我是王五")
    }

    when (b) {
        4, 5 -> println("b的值是4或者5")//条件可以写在一起，
        in 1..10 -> println("在区间1到10之间")//支持in  ,!in写法
        !in 50..100 -> println("不在50到100之间")
        is Int -> println("是整型")//支持is  !is写法
    }

    when {
        b == 1 -> println("b的值是1") //不传参，取代if  else 的写法，不传参数
        b == 2 -> println("b的值是2")
        else -> println("b的值不知道是多少")
    }

    var d = when (b) { //when语句作为表达式，可以进行赋值
        1 -> 11
        2 -> 22
        else -> 8
    }
    println(d)
}

fun conditionfor() {
    var a = arrayOf(4, 5, 6)
    for (b in a) {
        println(b)
    }
    for (c in a.withIndex()) {
        println(c)
    }
    for (d in a) {
        if (d == 4) continue //结束本次循环，继续下一次
        if (d == 5) break //跳出循环
    }

    oop@ for (e in a) {  //以名字加上@符号 给表达式取名
        for (j in a) {
            break@oop //跳出最外层循环
        }
    }


}

fun conditionwhile() {
    var a = 0
    while (a > 0) { //满足条件 就会继续执行
        println(--a)
    }
    println("--------------")
    do {
        println(--a)  //先执行一次，在进去while判断
    } while (a > 0)


}









package com.thinkwithu.www.kotlindemo.dsl

/**
 * Author: sean
 * Date: 2019/5/14 11:15
 */

/**
 * <html>
 *     <body>
 *    </body>
</html>
 */

fun main() {
    //高阶函数
    val html = html {
        head {

        }
        body {
            div {

            }
        }

    }
    println(html)
}

fun Body.div(block: () -> Unit) {
    val d=Div()
    setTag(d)
}


fun html(block: Html.() -> Unit): Html {
    val h = Html()
    block(h)
    return h
}

fun Html.body(block:Body.() -> Unit) {
    val b = Body()
    block(b)
    setTag(b)
}

fun Html.head(block: () -> Unit) {
    val h = Head()
    setTag(h)
}


open class Tag(val name: String) {
    val list = ArrayList<Tag>()

    fun setTag(tag: Tag) {
        list.add(tag)
    }

    override fun toString(): String {
        val stringBuilder = StringBuilder()
        stringBuilder.append("<$name>")
        list.forEach { stringBuilder.append(it.toString()) }
        stringBuilder.append("</$name>")
        return stringBuilder.toString()
    }
}

class Html : Tag("html")
class Body : Tag("body")
class Head : Tag("head")
class Div : Tag("div")
package com.thinkwithu.www.kotlindemo.fanxing

/**
 * Author: sean
 * Date: 2019/5/8 10:17
 */

fun main(args: Array<String>) {
    aaa.cc()
}

abstract class annimal

class Dog : annimal()

class cat : annimal()

open class Box<T>(thing: T)

class AnnimalBox(annimal: annimal) : Box<annimal>(annimal)


class aaa() {
    companion object {
        var a = ""
        fun cc() {

        }
    }
}
package com.thinkwithu.www.kotlindemo.fanxing.函数回调

/**
 * Author: sean
 * Date: 2019/5/13 14:51
 */


fun main() {
    val us = usa()
    us.chinesehome({
        it.copy()
    })
}

data class xinpian(var name: String)

class aaa(aaa5: Int) {
}

class aaa1(var int5: Int) {
    fun cc(){
        int5=9
    }
}

class chinese() {
    val us = usa()

}

class usa() {
    fun chinesehome(f: (xinpian) -> Unit) {
        val xinpian = xinpian("小霸王")
        f.invoke(xinpian)
    }
}


package com.thinkwithu.www.kotlindemo.fanxing

/**
 * Author: sean
 * Date: 2019/5/8 16:25
 */


fun main() {
//    danli.instance.name
//    danli.instance.age
//    println(text(C()))
    //获取函数的引用，用::函数名可以获取函数的引用
    /*  println(jisuan(4, 7, ::add))
      //lambda 表达式
      println(jisuan(77, 99, { m, n ->
          println()
          m - n
      }))
      //lambda表达式  去括号  括号前移
      println(jisuan(4, 9) { m, n ->
          m + n
      })*/
  /*  lamba(4)
    //使用lambda的时候，如果参数只有一个，那么可以省略参数不写，默认参数就是it
    jisuan(4, {
        it + 10
    })*/
    var list= listOf<String>("a","b","c")
   /* list.filter {  }*/

}

class danli() {
    var name = "asd"
    val age by lazy {
        5
    }
    //lateinit  不能修饰基本类型
    lateinit var height: String

    companion object {
        val instance by lazy {
            danli()
        }
    }

}


open class A
class B : A()
class C : A()
class D : A()

fun text(a: A): Boolean {
    return when (a) {
        is B -> true
        is D -> true
        else -> false
    }
}


fun add(a: Int, b: Int) = a + b
fun jian(a: Int, b: Int) = a - b

//高阶函数
fun jisuan(a: Int, b: Int, block: (Int, Int) -> Int): Int {
    return block.invoke(a, b)
}

//高阶函数
fun jisuan(a: Int, block: (Int) -> Int): Int {
    return block.invoke(a)
}

val lamba = { a: Int ->
    a
}








package com.thinkwithu.www.kotlindemo.fanxing.四大函数


/**
 * Author: sean
 * Date: 2019/5/13 11:33
 */

fun main(args: Array<String>) {
    val list = arrayListOf<String>("aaa")
    /**
     * 1.任何类型的扩展方法
     * 2.参数是有接收者的函数
     * 返回值是自己
     */
    list.apply {
        add("222")
        add("222")
    }

    /**
     * 1.参数是有一个参数的函数，参数函数的返回值是泛型R
     * 函数的返回值是参数函数的返回值
     */
    list.let {
        it.add("44")
        "ssss"
    }.length

    /**
     * 相当于是apply和let方法的合成题
     * 有两个参数，第一个参数是任意类型，第二个参数是有接收类型的函数，
     * 函数的返回值是第二个函数参数的返回值
     */
    with(8, {
        toString()
        "aaa"
    }).length

    /*
    1.参数是有接收类型的函数，接收类型是调用类型
    函数的返回值是函数参数的返回值
     */
    list.run {
        add("aaa")
        "rrrr"
    }.toString()


}

package com.thinkwithu.www.kotlindemo.heima

import java.lang.Exception
import java.math.BigInteger

/**
 * Copyright (C), 2015-2019, 北京九州申友教育咨询有限公司
 * Author: sean
 * Date: 2019/5/5 10:54
 * Description: ${DESCRIPTION}
 */

//程序的主方法
fun main(argus: Array<String>) {
//    println(sayHello("xiaozhang"))
//    println(checkAge(19))
//    saveLog(1)
//    println(darary("滁洲岛"))
//    qujian()
//    add(3, 2)
//    hanshu()
//    zhouchang(a = 6.3f)
//    jiaohu()
    println(jiecheng(BigInteger("100000")))
}

fun basic1() {
    var a = 5  //智能推断类型  var  可变的数据
    var b: Byte = 9 //显示指定类型
    var c: Int //指定类型，可以被重新赋值
    c = 99
    val number = "No.123598" //val 是常量，不能被修改，只读数据，确定了就不能被修改
//    number = "sdfdf"

    var d: Boolean
    d = 5 > 4

}


fun sayHello(name: String): String {
    return name
}

fun checkAge(age: Int): Boolean {
    return age > 18
}

fun saveLog(logLeavel: Int) {
    println(logLeavel)
}


//字符串模板    用$符号
fun darary(place: String): String {
    var comtent = """
        今天我去了${place}这里游玩，真好玩
    """.trimIndent()
    return comtent
}


fun qujian() {
    var a = 1..100000
    var result: Int = 0
    for (c in a) {
        result = result + c
    }
    println(result)
}

fun add(a: Int, b: Int) = a + b

fun hanshu() {
    var a = { x: Int, y: Int -> x + y }
    var b: (Int, Int) -> Int = { x, y -> x + y }
    var resule = a(3, 6)
    println(resule)
}


fun zhouchang(pi: Float = 3.14f, a: Float): Float = a * pi


fun jiaohu() {
    while (true) {
        try {
            println("********************************")
            println("请输入第一个数字")
            var a = readLine()!!.toInt()
            println("请输入第二个数字")
            var b = readLine()!!.toInt()
            println("$a + $b =${a + b}")
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }
}



// tailrec  尾递归 优化   不管多少次都要执行
tailrec fun  jiecheng(a: BigInteger): BigInteger {
    println(100000 - a.toInt())
    if (a == BigInteger.ONE) {
        return BigInteger.ONE
    } else {
        return jiecheng(a - BigInteger.ONE)
    }
}





















package com.thinkwithu.www.kotlindemo.heima26

/**
 * Author: sean
 * Date: 2019/5/5 17:36
 */

fun main(args: Array<String>) {
//    han_shu_shi()
    //::函数名，用于声明函数对象
    var add = ::add
    //有两种方式，函数对象的调用，
    println(add(1, 2))
    //这种方式更加安全
    println(add?.invoke(1, 2))


}

fun han_shu_shi() {
    var stringlist = listOf<String>("a", "b", "c")
    //d第一种写法
    /* for (i in stringlist) {
         println(i)
     }
     //第二种写法
     var print = fun(name: String) {
         println(name)
     }
     stringlist.forEach(
         print
     )
     //第三种写法,把参数抽了出来 it就是参数，我们可以直接写函数体
     stringlist.forEach {
         println(it)
     }*/
    println(stringlist.findLast {
        it.equals("a") && it.equals("1")
    })
}

fun add(a: Int,b:Int): Int {
    return a
}

//可变参数 vararg
fun add1(vararg a: Int): Int {
    var result = 0
    a.forEach {
        result += it
    }
    return result
}



package com.thinkwithu.www.kotlindemo

import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import android.widget.Button

class MainActivity : AppCompatActivity() {


    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
    }




}
package com.thinkwithu.www.kotlindemo

/**
 * Copyright (C), 2015-2019, 北京九州申友教育咨询有限公司
 * Author: sean
 * Date: 2019/4/25 17:23
 * Description: ${DESCRIPTION}
 */

fun main() {
    //编译器可以自动识别类型，所以不需要显示传入类型
//    var t1 = generic(8)
//    var t2 = generic<String>("44")
//    t1.dd(78)
//    println(t1.cc)
//    println(t2.cc)
//    printlnn("haha")
//    printlnn(995)
//    printlnn(true)
//    jjj(aaaa())

//    var color = getColor.Red
//    println(getColor.values())
//    println(getColor.valueOf("Blue"))
//    println(color.name)
//    println(color.ordinal)
    /* eatDrink(object : annimal("长颈鹿") {
         override fun eat() {
             super.eat()
             println("$this 在喝水")
         }
     })
     //通过对象表达式，我们可以直接拿到类的对象
     var aa = object : annimal("") {

     }
     var aa1 = object {

     }*/
    val pen1 = pen
    val pen2 = pen
    println(pen1 === pen2)


}

//泛型，即参数化类型，把类型参数化，就和实参一样，一开始我们不知道要传什么类型的参数，所以就用一个参数来代替这个类型，
//当我们准备传入参数的时候，在把类型带上去，是为了避免之后的代码出现问题，这样的话 我们需要string类型，就必须传string，传int就会报错，能从编译期解决类型转换报错的问题

class generic<T>(a: T) {
    val cc = a
    fun dd(r: T) {
        println(r)
    }
}


//泛型函数

fun <T> printlnn(value: T) {
    when (value) {
        is Int -> println("传过来的是整形数字$value")
        is String -> println("穿过来的是字符串${value.reversed()}")
        else -> println("啥也不是")
    }
}

//泛型约束

open class aaa
interface bbb


fun <T : aaa> haha(value: T) {

}

class aaaa : aaa(), bbb

//多个条件的泛型约束，使用where语句，并且只能有一个条件是类，其余都可以是接口
//where语句，多个条件同时满足，才能传这个类型，相当于&&
fun <T> jjj(value: T)
        where T : aaa,
              T : bbb {

}


//枚举类用enum修饰，当一个类的对象固定且有限时使用枚举类，可以达到类型安全的意义
enum class getColor {
    Red(), Blue(), White()
}

//对象表达式，对一个类作了轻微的改变，比如增加了某些功能，但却不需要新建子类，有点装饰器的味道，用object修饰
//就是java中的匿名内部类

open class annimal(var string: String) {
    open fun eat() {
        println("$string 在吃早饭")
    }
}

fun eatDrink(a: annimal) {
    a.eat()
}

//对象声明
//我们使用object来申明一个对象，相当于是拿到了类的实例，并且是单例的，
//相当于，我们可以很便捷的拿到一个对象，绕过了去申明类的过程
var c2c = object : annimal("a") {

}

fun text3() {
    c2c.eat()

}


object pen {
    fun write() {
        println("我在写字")
    }
}

//可以有父类，其实相当于是pencil 继承了父类，并且还得到了pencil类的对象，
//同时做了两个步骤，继承了父类，和实例化了对象
object pencil : annimal("劳资") {


}

class outer {
    var name = "wo"

    object inner {
        fun innerDo() {
//            println(name)  当声明对象在一个类的内部时，并不能访问到外部类的成员
        }

    }
}

var o = outer()
fun text1() {
//    println(o.inner) 外部类不能通过它的实例访问到这个对象
    outer.inner.innerDo()//只能通过类名直接访问
}


//伴生对象，从名字看，我们就可以看出来相当于这个对象是伴随着其他东西依托存在的
//用companion修饰，

class floor {
    companion object inner { //其实就是在类 内部的对象声明加了companion关键字，使得inner成了伴生对象
        fun innerDo() {

        }
    }
}

fun text4() {
    floor.innerDo() //伴生对象的成员可以被外部类直接访问，有点静态属性的味道，可以通过类名可以得到
}

class phone {
    companion object {  //我们可以省略掉伴生对象的名字，因为这个名字其实没多大意义
        fun dosomthing() {
            println("do")
        }
    }
}

fun text5() {
    val phone1 = phone.Companion  //我们可以通过类.companion拿到伴生对象，由此可以看出我们类的伴生对象只能有一个，即companion关键字只能用一次
    phone1.dosomthing()
}




























package com.thinkwithu.www.kotlindemo.weituo

/**
 * Author: sean
 * Date: 2019/5/6 11:33
 */
class Biaodi : Xiwan {
    override fun washing() {
        println("表弟不耐烦在洗碗")
    }

    var a = 4 + 5
    operator fun plus(a: Int) {

    }

    var cc = "aa"
        set(value) {
            field = "99"
        }


}package com.thinkwithu.www.kotlindemo.weituo

/**
 * Author: sean
 * Date: 2019/5/6 11:32
 */
class Me : Xiwan by Biaodi() {
}package com.thinkwithu.www.kotlindemo.weituo

/**
 * Author: sean
 * Date: 2019/5/6 11:33
 */

fun main() {
    var me = Me()
    me.washing()
}package com.thinkwithu.www.kotlindemo.weituo

/**
 * Author: sean
 * Date: 2019/5/6 11:31
 */
interface Xiwan {
    fun washing()
}package com.thinkwithu.www.kotlindemo

import org.junit.Test

import org.junit.Assert.*

/**
 * Example local unit test, which will execute on the development machine (host).
 *
 * See [testing documentation](http://d.android.com/tools/testing).
 */
class ExampleUnitTest {
    @Test
    fun addition_isCorrect() {
        assertEquals(4, 2 + 2)
    }
}
